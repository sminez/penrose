<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits for writing and composing hooks."><title>penrose::core::hooks - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="penrose" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../penrose/index.html"><img src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../penrose/index.html"><img src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" alt="logo"></a><h2 class="location"><a href="#">Module hooks</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">penrose</a>::<wbr><a href="../index.html">core</a>::<wbr><a class="mod" href="#">hooks</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/penrose/core/hooks.rs.html#1-476">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits for writing and composing hooks.</p>
<h3 id="hook-points"><a href="#hook-points">Hook points</a></h3>
<p>Penrose offers several differnt hook points where you are able to provide custom
logic to execute as part of the main WindowManager event loop. Unlike logic you
add as KeyEventHandlers, hooks will be run automatically by Penrose as and when
the conditions for there execution arises. Each hook point requires a specific
trait to be implemented and in the simplest case, functions with the correct
type signature can be used directly (though you will likely want to implement
traits directly if you are looking for more control over how your hook logic is
run.</p>
<h4 id="startup-hooks"><a href="#startup-hooks">Startup Hooks</a></h4>
<p>Startup hooks are implemented using the <a href="trait.StateHook.html" title="trait penrose::core::hooks::StateHook"><code>StateHook</code></a> trait, allowing you access
to the pure WindowManager internal <a href="../struct.State.html" title="struct penrose::core::State"><code>State</code></a> and the <a href="../../x/trait.XConn.html" title="trait penrose::x::XConn"><code>XConn</code></a> in order to run
any set up code you need which requires the the bindings to already have been
grabbed but before any existing clients are parsed and managed by the WindowManager.</p>
<blockquote>
<p><strong>NOTE</strong>: Startup hooks are run to completion before entering the main event loop.</p>
</blockquote>
<h4 id="event-hooks"><a href="#event-hooks">Event Hooks</a></h4>
<p>The <a href="trait.EventHook.html" title="trait penrose::core::hooks::EventHook"><code>EventHook</code></a> trait allows you to pre-process incoming <a href="../../x/event/enum.XEvent.html" title="enum penrose::x::event::XEvent"><code>XEvent</code></a>s as they
arrive from the X server, <em>before</em> they are seen by the default event handling logic.
This allows you to intercept or modify incoming events as you need and act
accordingly. Maybe you want to keep track of changes to a specific property on clients
or maybe you want to know if a specific client is being destroyed.</p>
<p>This hook returns a <code>bool</code> indicating whether or not the default event handling logic
needs to run after your hook has finished: to run the default handling you should return
<code>true</code>, to skip the handling (and prevent the normal behviour for such an event) you
can return <code>false</code>.</p>
<blockquote>
<p><strong>NOTE</strong>: Be careful about disabling default event handling! If you drop events
that are required for the normal behaviour of the WindowManager then you
will need to make sure that you track and maintain any required state
that may now be missing.</p>
</blockquote>
<h4 id="manage-hooks"><a href="#manage-hooks">Manage Hooks</a></h4>
<p><a href="trait.ManageHook.html" title="trait penrose::core::hooks::ManageHook"><code>ManageHook</code></a>s let you run some additional logic to optionally modify the pure
window manager state <em>after</em> a newly managed client has been processed and stored, but
before that change is applied to the X server. This allows you to modify how the new
client is set up when it first appears, such as moving it to a specific workspace or
marking it as floating in a specific position. There are some reference hooks in the
<a href="../../extensions/hooks/manage/index.html" title="mod penrose::extensions::hooks::manage">extensions module</a> that can serve as a starting point for looking at the sorts of
things that are possible.</p>
<blockquote>
<p><strong>NOTE</strong>: ManageHooks should <em>not</em> directly trigger a refresh of the X state!
They are already called by the XConn immediately before refreshing so all
triggering a refresh directly will do is run the refresh twice: once with
the inital state of the client before your hook was applied and once after.</p>
</blockquote>
<h4 id="layout-hooks"><a href="#layout-hooks">Layout Hooks</a></h4>
<p>Finally we have <a href="trait.LayoutHook.html" title="trait penrose::core::hooks::LayoutHook"><code>LayoutHook</code></a>s which operate a little differently, in that they have
two methods to implement. Layout hooks are run <em>around</em> whatever <a href="../layout/trait.Layout.html" title="trait penrose::core::layout::Layout">Layout</a> is active
for the focused workspace, allowing you to modify the screen dimensions available for the
layout algorithm before it runs and editing the list of window positions it generates
before they are applied. This lets you do things like prevent windows being positions on
certain parts of the screen, or injecting/removing additional window positions.</p>
<p>This is somewhat similar to the <a href="../layout/trait.LayoutTransformer.html" title="trait penrose::core::layout::LayoutTransformer"><code>LayoutTransformer</code></a> trait which is a wrapper around a
specific Layout, but it doesn’t allow for introspection of the underlying Layout or
responding to Messages. On the plus side, layout hooks are registered and run centrally
rather than needing to be applied to each Layout you want to add that behaviour to.</p>
<h4 id="refresh-hooks"><a href="#refresh-hooks">Refresh Hooks</a></h4>
<p>Refresh hooks are implemented using the same <a href="trait.StateHook.html" title="trait penrose::core::hooks::StateHook"><code>StateHook</code></a> trait used for Startup hooks.
In this case however, your hook will be run each time the XConn refreshes the X state in
response to changes being made to the internal state of the WindowManager.
This is one of the more general purpose hooks available for you to make use of and can be
used to run code any time something changes in the internal state of your window manager.</p>
<h3 id="setting-and-composing-hooks"><a href="#setting-and-composing-hooks">Setting and composing hooks</a></h3>
<p>Each kind of hook has a corresponding <code>compose_or_set_*_hook</code> method on the <a href="../struct.Config.html" title="struct penrose::core::Config">Config</a>
struct. If multiple hooks of the same type are registered they are composed together as
a stack, with the most recently added hook running first (keep this in mind if the hooks
you are registering have any potential interactions in how they operate).</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ComposedEventHook.html" title="struct penrose::core::hooks::ComposedEventHook">ComposedEventHook</a></div><div class="desc docblock-short">The result of composing two event hooks using <code>then</code></div></li><li><div class="item-name"><a class="struct" href="struct.ComposedLayoutHook.html" title="struct penrose::core::hooks::ComposedLayoutHook">ComposedLayoutHook</a></div><div class="desc docblock-short">The result of composing two state hooks using <code>then</code></div></li><li><div class="item-name"><a class="struct" href="struct.ComposedManageHook.html" title="struct penrose::core::hooks::ComposedManageHook">ComposedManageHook</a></div><div class="desc docblock-short">The result of composing two manage hooks using <code>then</code></div></li><li><div class="item-name"><a class="struct" href="struct.ComposedStateHook.html" title="struct penrose::core::hooks::ComposedStateHook">ComposedStateHook</a></div><div class="desc docblock-short">The result of composing two state hooks using <code>then</code></div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.EventHook.html" title="trait penrose::core::hooks::EventHook">EventHook</a></div><div class="desc docblock-short">Handle an <a href="../../x/event/enum.XEvent.html" title="enum penrose::x::event::XEvent">XEvent</a>, return <code>true</code> if default event handling should be run afterwards.</div></li><li><div class="item-name"><a class="trait" href="trait.LayoutHook.html" title="trait penrose::core::hooks::LayoutHook">LayoutHook</a></div><div class="desc docblock-short">Logic to run before and after laying out clients</div></li><li><div class="item-name"><a class="trait" href="trait.ManageHook.html" title="trait penrose::core::hooks::ManageHook">ManageHook</a></div><div class="desc docblock-short">Action to run when a new client becomes managed.</div></li><li><div class="item-name"><a class="trait" href="trait.StateHook.html" title="trait penrose::core::hooks::StateHook">StateHook</a></div><div class="desc docblock-short">An arbitrary action that can be run and modify <a href="../struct.State.html" title="struct penrose::core::State">State</a></div></li></ul></section></div></main></body></html>