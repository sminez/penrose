<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Penrose Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="builtin/index.html"><strong aria-hidden="true">2.</strong> Built In Functionality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="builtin/layouts.html"><strong aria-hidden="true">2.1.</strong> Layouts</a></li><li class="chapter-item expanded "><a href="builtin/actions.html"><strong aria-hidden="true">2.2.</strong> Actions</a></li><li class="chapter-item expanded "><a href="builtin/ui.html"><strong aria-hidden="true">2.3.</strong> UI</a></li></ol></li><li class="chapter-item expanded "><a href="extensions/index.html"><strong aria-hidden="true">3.</strong> Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extensions/hooks.html"><strong aria-hidden="true">3.1.</strong> Hooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extensions/startup-hooks.html"><strong aria-hidden="true">3.1.1.</strong> Startup Hooks</a></li><li class="chapter-item expanded "><a href="extensions/event-hooks.html"><strong aria-hidden="true">3.1.2.</strong> Event Hooks</a></li><li class="chapter-item expanded "><a href="extensions/manage-hooks.html"><strong aria-hidden="true">3.1.3.</strong> Manage Hooks</a></li><li class="chapter-item expanded "><a href="extensions/refresh-hooks.html"><strong aria-hidden="true">3.1.4.</strong> Refresh Hooks</a></li></ol></li><li class="chapter-item expanded "><a href="extensions/ewmh.html"><strong aria-hidden="true">3.2.</strong> EWMH</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="overview/index.html"><strong aria-hidden="true">4.</strong> Overview of Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/pure-vs-x.html"><strong aria-hidden="true">4.1.</strong> Pure Code vs X Code</a></li><li class="chapter-item expanded "><a href="overview/data-structures.html"><strong aria-hidden="true">4.2.</strong> Data Structures</a></li></ol></li><li class="chapter-item expanded "><a href="building/index.html"><strong aria-hidden="true">5.</strong> Building on top of penrose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building/actions.html"><strong aria-hidden="true">5.1.</strong> Actions</a></li><li class="chapter-item expanded "><a href="building/layouts.html"><strong aria-hidden="true">5.2.</strong> Layouts</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Hooks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> State Extensions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Example: Named Scratchpads</div></li></ol></li><li class="chapter-item expanded "><a href="faq.html">FAQs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Penrose Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <a href="https://github.com/sminez/penrose">Penrose</a>: a modular tiling window manager library for X11 written in Rust.</p>
<p>Unlike most other tiling window managers, <code>Penrose</code> is not a binary that you install on your
system. Instead, you use it like a normal dependency in your own crate for writing your own
window manager. Don't worry, the top level API is well documented and a lot of things will
work out of the box, and if you fancy digging deeper you'll find lots of opportunities to
customise things to your liking.</p>
<p>If you are new to Rust it is worthwhile taking a look at the <a href="https://www.rust-lang.org/learn">learning materials</a>
provided by the Rust project to get up to speed on how the language works. (The rest of
this book assumes you are somewhat familiar with the language).</p>
<p>The rest of this book covers the concepts and implementation of <code>Penrose</code> at a level of
detail that should allow you to implement your own extensions and custom functionality
on top of the base library. If you just want to skip ahead to a working, minimal window
manager then take a look at the Quickstart section of this book or the <a href="https://github.com/sminez/penrose/tree/develop/examples">examples</a>
directory of the GitHub repo. (My <a href="https://github.com/sminez/my-penrose-config">personal config</a> is also available to take a look
at if you want to see what something a bit more involved looks like!)</p>
<p>As with all crates on crates.io, the crate level documentation is also available
<a href="https://docs.rs/penrose">on docs.rs</a>.</p>
<p>Happy window managing!</p>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>So you'd like to manage your windows, maybe even tile them?</p>
<p>Well aren't you in luck!</p>
<p>The following is a quick guide for how to get your system set up for building a penrose based
window manager and getting it running. By the end of this guide you will have a <em>very</em> minimal
window manager that you can use as a starting point.</p>
<p>If you've ever tried out <a href="https://xmonad.org/">xmonad</a> before then the overall design and feel of how penrose works
should feel (somewhat) familiar. The key thing is this: penrose is a library for writing a window
manager. It's not a pre-built window manager that you then configure via a config file. In practical
terms what that means is that it's time to get our hands dirty with writing some code!</p>
<h2 id="step-0-getting-set-up-with-rust"><a class="header" href="#step-0-getting-set-up-with-rust">Step 0: Getting set up with Rust</a></h2>
<p>If you have Rust on your system already, congrats! You can skip this section.</p>
<p>For everyone else, head on over to <a href="https://www.rust-lang.org/">rust-lang.org</a> and click on the big "Get Started button"
which will advise you to curl a setup script straight into <strong>sh</strong>. If you'd prefer to see what
you are about to run, the following should do the trick:</p>
<pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs &gt; rustup.sh

# Open and peruse in your editor of choice
$ $EDITOR rustup.sh

# Then, to carry out the actual install
$ chmod +x rustup.sh
$ ./rustup.sh
</code></pre>
<p>Now simply sit back and wait for while Rust is installed on your system.</p>
<h2 id="initialising-your-window-manager-crate"><a class="header" href="#initialising-your-window-manager-crate">Initialising your window manager crate</a></h2>
<p>"Crates" are Rust's term for what you might be more used to calling a package or project.
Either way, for your window manager you are going to want to make a new <em>binary</em> crate like so:</p>
<pre><code class="language-bash">$ cargo new --bin my_penrose_config
$ cd my_penrose_config
$ exa -T  # or just plain old 'ls' if you prefer
.
├── Cargo.toml
└── src
   └── main.rs
</code></pre>
<p>If you open up <code>main.rs</code> you should see a simple hello world program:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>We can run this using <code>cargo run</code> to check everything is good to go:</p>
<pre><code class="language-bash">$ cargo run
   Compiling example v0.1.0 (/home/roger/my_penrose_config)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/example`
Hello, world!
</code></pre>
<p>Nice! Time to write a window manager.</p>
<h2 id="writing-your-mainrs"><a class="header" href="#writing-your-mainrs">Writing your main.rs</a></h2>
<p>You should now have a new git repo with the content shown above. At the moment,
your <strong>main.rs</strong> is just a simple Hello World program (we'll be fixing that soon)
but first we need to add some dependencies. Most importantly, we need to add
penrose itself but we're also going to add another crate as well to make our lives
a little easier: <a href="https://crates.io/crates/tracing-subscriber">tracing-subscriber</a> can be used to collect and process the logs
that penrose generates as it runs. It's by no means <em>required</em> to collect the logs
but it definitely helps track down issues with your window manager if you can see
what's going on inside as it runs!</p>
<p>Thankfully, adding new dependencies is also something cargo can handle for us! It
even handles enabling optional features for us (which is handy, because we need to
do just that with <code>tracing-subscriber</code>):</p>
<pre><code class="language-bash">$ cargo add tracing-subscriber --features env-filter
$ cargo add penrose
</code></pre>
<p>With that done, we're going to copy the <a href="https://github.com/sminez/penrose/blob/develop/examples/minimal/main.rs">minimal example</a> from the penrose repository in
GitHub as our window manager. Either copy and paste the contents of the example into your
<code>main.rs</code> or (my prefered choice) use wget to pull it directly from GitHub:</p>
<pre><code class="language-bash">$ cd src
$ rm main.rs
$ wget https://raw.githubusercontent.com/sminez/penrose/develop/examples/minimal/main.rs
</code></pre>
<p>For reference, your <code>main.rs</code> should now look like this:</p>
<pre><pre class="playground"><code class="language-rust">//! penrose :: minimal configuration
//!
//! This file will give you a functional if incredibly minimal window manager that
//! has multiple workspaces and simple client / workspace movement.
use penrose::{
    builtin::{
        actions::{
            exit,
            floating::{sink_clicked, MouseDragHandler, MouseResizeHandler},
            modify_with, send_layout_message, spawn,
        },
        layout::messages::{ExpandMain, IncMain, ShrinkMain},
    },
    core::{
        bindings::{
            parse_keybindings_with_xmodmap, KeyEventHandler, MouseEventHandler, MouseState,
        },
        Config, WindowManager,
    },
    map,
    x11rb::RustConn,
    Result,
};
use std::collections::HashMap;
use tracing_subscriber::{self, prelude::*};

fn raw_key_bindings() -&gt; HashMap&lt;String, Box&lt;dyn KeyEventHandler&lt;RustConn&gt;&gt;&gt; {
    let mut raw_bindings = map! {
        map_keys: |k: &amp;str| k.to_string();

        "M-j" =&gt; modify_with(|cs| cs.focus_down()),
        "M-k" =&gt; modify_with(|cs| cs.focus_up()),
        "M-S-j" =&gt; modify_with(|cs| cs.swap_down()),
        "M-S-k" =&gt; modify_with(|cs| cs.swap_up()),
        "M-S-q" =&gt; modify_with(|cs| cs.kill_focused()),
        "M-Tab" =&gt; modify_with(|cs| cs.toggle_tag()),
        "M-bracketright" =&gt; modify_with(|cs| cs.next_screen()),
        "M-bracketleft" =&gt; modify_with(|cs| cs.previous_screen()),
        "M-grave" =&gt; modify_with(|cs| cs.next_layout()),
        "M-S-grave" =&gt; modify_with(|cs| cs.previous_layout()),
        "M-S-Up" =&gt; send_layout_message(|| IncMain(1)),
        "M-S-Down" =&gt; send_layout_message(|| IncMain(-1)),
        "M-S-Right" =&gt; send_layout_message(|| ExpandMain),
        "M-S-Left" =&gt; send_layout_message(|| ShrinkMain),
        "M-semicolon" =&gt; spawn("dmenu_run"),
        "M-Return" =&gt; spawn("st"),
        "M-A-Escape" =&gt; exit(),
    };

    for tag in &amp;["1", "2", "3", "4", "5", "6", "7", "8", "9"] {
        raw_bindings.extend([
            (
                format!("M-{tag}"),
                modify_with(move |client_set| client_set.focus_tag(tag)),
            ),
            (
                format!("M-S-{tag}"),
                modify_with(move |client_set| client_set.move_focused_to_tag(tag)),
            ),
        ]);
    }

    raw_bindings
}

fn mouse_bindings() -&gt; HashMap&lt;MouseState, Box&lt;dyn MouseEventHandler&lt;RustConn&gt;&gt;&gt; {
    use penrose::core::bindings::{
        ModifierKey::{Meta, Shift},
        MouseButton::{Left, Middle, Right},
    };

    map! {
        map_keys: |(button, modifiers)| MouseState { button, modifiers };

        (Left, vec![Shift, Meta]) =&gt; MouseDragHandler::boxed_default(),
        (Right, vec![Shift, Meta]) =&gt; MouseResizeHandler::boxed_default(),
        (Middle, vec![Shift, Meta]) =&gt; sink_clicked(),
    }
}

fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt()
        .with_env_filter("info")
        .finish()
        .init();

    let conn = RustConn::new()?;
    let key_bindings = parse_keybindings_with_xmodmap(raw_key_bindings())?;
    let wm = WindowManager::new(Config::default(), key_bindings, mouse_bindings(), conn)?;

    wm.run()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn bindings_parse_correctly_with_xmodmap() {
        let res = parse_keybindings_with_xmodmap(raw_key_bindings());

        if let Err(e) = res {
            panic!("{e}");
        }
    }
}</code></pre></pre>
<h3 id="checking-were-good-to-go"><a class="header" href="#checking-were-good-to-go">Checking we're good to go</a></h3>
<p>Hopefully you've spotted that the end of the example includes a test. Now, it's entirely up
to you whether or not you keep (and run) the test but it's highly recommended that you do.
It's actually recommended that you write <em>more</em> tests for your window manager as you extend
the features you want and write your own custom code!</p>
<p>Penrose itself has a pretty comprehensive test suite of the main logic and provides a variety
of ways for you to check and confirm that things are behaving in the way that you expect.
To run our test (and any others that you have added yourself) we simply need to run <code>cargo test</code>:</p>
<blockquote>
<p><strong>NOTE</strong>: This test (and the example itself) require you to have the <a href="https://wiki.archlinux.org/title/Xmodmap">xmodmap</a> utility
installed on your system in order to parse our keybindings.</p>
<p>Make sure you have it installed before going further!</p>
</blockquote>
<pre><code class="language-bash">$ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.03s
     Running unittests src/main.rs (target/debug/deps/example-1562870d47d380ed)

running 1 test
test tests::bindings_parse_correctly_with_xmodmap ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
</code></pre>
<p>You'll see a lot more output the first time you run the test as things are compiled, but so long
as you see the test passing we should be good to take things for a spin!</p>
<h2 id="making-use-of-our-new-window-manager"><a class="header" href="#making-use-of-our-new-window-manager">Making use of our new window manager</a></h2>
<p>So far we've been building things in <code>debug</code> mode, which is exactly what we want when we're testing
things out and running any test suites we have. For actually making use of our new window manager
though, we want to switch to <code>release</code> mode:</p>
<pre><code class="language-bash">$ cargo build --release
</code></pre>
<p>You'll see a lot of output the first time round as the dependencies of Penrose itself are compiled,
but after that your re-compile should be pretty quick following any changes that you make. Once the
binary is compiled you should see it as a new executable in the <code>target/release</code> directory.</p>
<p>The simplest way of running your new window manager is to login via a TTY and place the following
in your <code>~/.xinitrc</code>:</p>
<pre><code class="language-bash">exec /home/roger/my_penrose_config/target/release/my_penrose_config &amp;&gt; ~/.penrose.log
</code></pre>
<p>Then, you can simply type <code>startx</code> after logging in and your window manager will start up, with the
log output available in my your home directory as <code>.penrose.log</code>!</p>
<p>If logging in and starting your graphical session from a TTY is "too hipster" for you (which, lets be
honest, it is), you might want to look at installing and running a <a href="https://wiki.archlinux.org/title/Display_manager#Run_~/.xinitrc_as_a_session">display manager</a> and using
something like <a href="https://wiki.archlinux.org/title/Display_manager#Run_~/.xinitrc_as_a_session">xinit-session</a> to make this a little nicer. Alternatively, dropping something like
the following into <code>/usr/share/xsessions</code> should also do the trick. The <a href="https://wiki.archlinux.org/title/Display_manager#Session_configuration">arch wiki</a> is a fantastic
place to read up on how to do these sorts of things whether you use Arch Linux or not.</p>
<pre><code class="language-desktop">[Desktop Entry]
Version=1.0
Name=Penrose Session
Comment=Use this session to run penrose as your desktop environment
Exec=sh -c "/home/roger/my_penrose_config/target/release/my_penrose_config &amp;&gt; ~/.penrose.log"
Icon=
Type=Application
DesktopNames=Penrose
</code></pre>
<h2 id="profit"><a class="header" href="#profit">Profit</a></h2>
<p>And that's it!</p>
<p>You are now the proud owner of a shiny new window manager. From this point on you can start tinkering
to your heart's content and setting things up exactly how you want. Speaking from personal experience,
I would advise that you commit your changes to your window manager <em>regularly</em> and that you make sure
you know how to revert to your last good state in case you manage to introduce any particularly nasty
bugs into your setup. If that happens, simply rebuild your previous good state and get to work on
fixing your bug.</p>
<p>The <a href="https://github.com/sminez/penrose/blob/develop/scripts/xephyr.sh">xephyr.sh</a> script in the GitHub repository can be used to run a given example in an embedded
X session if you want a little bit of safety while you sanity check changes that you are making.
Details of how it works are in a comment at the top of the script and <code>examples/local_test</code> is git
ignored for you to be able to have a place to try things out.</p>
<p>The rest of this book goes on to cover some of the inner workings of the main library, how to write
and work with extensions and generally have fun tinkering with your window manager.</p>
<p>Happy window managing!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-functionality"><a class="header" href="#built-in-functionality">Built In Functionality</a></h1>
<p>Out of the box, penrose offers a minimal amount of functionality that can be used
to write your own window manager. The core of the library is the state management
and X server interaction logic, but there are a number of types and traits available
for building out custom behaviour as you see fit.</p>
<p>Partly to exist as a reference (and also to bootstrap a minimal window manager) the
<a href="https://github.com/sminez/penrose/tree/develop/src/builtin">builtin</a> module is provided with a small number of examples for each of the
pieces of functionality on offer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layouts"><a class="header" href="#layouts">Layouts</a></h1>
<p>The built in layout functionality is primarily focused around giving a default
experience that is useful out of the box. With that in mind, things are restricted
to a couple of simple layouts that showcase the message handling capabilities of
the <code>Layout</code> trait, the associated <code>Messages</code> and a couple of <code>Transformers</code> that
combine nicely to give your windows a little bit of breathing room.</p>
<h2 id="layouts-1"><a class="header" href="#layouts-1">Layouts</a></h2>
<h3 id="monocle"><a class="header" href="#monocle">Monocle</a></h3>
<pre><code>+-----------------------+
|                       |
|                       |
|                       |
|                       |
|                       |
+-----------------------+
</code></pre>
<p>The monocle layout is lifted directly from <code>dwm</code> as what is possibly the simplest
possible layout: the currently focused window gets the full available screen
space and everything else is hidden.</p>
<blockquote>
<p><strong>NOTE</strong>: This is not the same thing as making a window fullscreen. With the
monocle layout you will still see the effect of any <code>LayoutTransformers</code> that
have been applied which may reduce the space available for the window.</p>
</blockquote>
<h3 id="main-and-stack"><a class="header" href="#main-and-stack">Main and Stack</a></h3>
<pre><code>+--------------+--------+
|              |        |
|              |        |
|              +--------+
|              |        |
|              |        |
+--------------+--------+
</code></pre>
<p>The default and primary layout for penrose is the <code>MainAndStack</code> which is a slight
generalisation of the default <code>tiled</code> layout from xmonad. There are several ways
to set it up but the common theme is the idea of a "main" area and stack (or
secondary) area that contains the windows that are not the current focus of what
you are doing. The number of windows allowed in the main area can be changed using
messages as can the proportions of the screen assigned to each area.</p>
<p>As you might expect you have the choice of whether the main area is on the left,
right, top or bottom of the screen. There are also a couple of <code>Messages</code> that can
be sent to switch between the different behaviours if you want to modify a single
layout rather than register several different ones.</p>
<h3 id="centered-main"><a class="header" href="#centered-main">Centered Main</a></h3>
<pre><code>+-----------+-----------+
|           |           |
|           |           |
+-----------+-----------+
|                       |
|                       |
+-----------+-----------+
|           |           |
|           |           |
+-----------+-----------+
</code></pre>
<p>There is also a modified version of the <code>MainAndStack</code> layout called <code>CenteredMain</code>
which provides two secondary areas, one either side of the main area. As with its
counterpart, you can rotate between having the secondary areas to the side or above
and below the main area by sending a <code>Rotate Message</code></p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<pre><code>+-------+-------+-------+
|       |       |       |
|       |       |       |
+-------+-------+-------+
|       |       |       |
|       |       |       |
+-------+-------+-------+
|       |       |       |
|       |       |       |
+-------+-------+-------+
</code></pre>
<p>The <code>Grid</code> layout will tile windows in the smallest <strong>nxn</strong> grid that can hold the
number of windows present on the workspace.</p>
<p>Please be aware that if there are not a square number of windows to be tiled, this
layout will leave gaps:</p>
<pre><code>+-------+-------+-------+
|       |       |       |
|       |       |       |
+-------+-------+-------+
|       |       |       |
|       |       |       |
+-------+-------+-------+
|       |       |
|       |       |
+-------+-------+
</code></pre>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>As mentioned above, there are a handful of built in messages that work with the
<code>MainAndStack</code> layout which are also generally applicable to other layouts with a
similar sort of set up. The <code>IncMain</code>, <code>ExpandMain</code> and <code>ShrinkMain</code> messages should
be relevant for any layout that emphasises some clients over others. The <code>Rotate</code> and
<code>Mirror</code> messages can be used if a single layout supports rotational and reflective
symmetry (or if pairs of layouts can be mapped to one another).</p>
<p>The <code>UnwrapTransformer</code> message is tied to the <code>LayoutTransformer</code> trait as a way of
removing a layout transformer from the underlying layout. Nothing needs to be done
to support this message as it is handled by the <code>LayoutTransformer</code> trait itself.</p>
<h2 id="transformers"><a class="header" href="#transformers">Transformers</a></h2>
<p>To showcase a couple of simple things that are possible with <code>LayoutTransformers</code>, there
is are the <code>ReflectHorizontal</code> and <code>ReflectVertical</code> transformers which do pretty much
what you would expect. To support the built in status bar there is also a <code>ReserveTop</code>
transformer that can be used to prevent layouts from positioning windows over a status
bar, and finally there is the <code>Gaps</code> transformer because (lets face it) most of us like
at least a <em>little</em> bit of space between our windows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p>When it comes to extending the behaviour of you window manager, the first and most
obvious thing to look at is running some custom code in response to a key binding
being pressed. In penrose, this is refered to as an <code>action</code>.</p>
<p>Actions can be anything from focusing a new window, to changing the layout algorithm
being used, to opening a terminal or running fully custom logic to find and display
amusing pictures of squirrels.</p>
<p>The choice is yours.</p>
<p>To help with some of the boilerplate and common cases, there are a couple of helper
functions that will generate a <code>KeyEventHandler</code> for you in a relatively simple
way. There are also a couple of built in actions for working with floating windows
and exiting penrose to get you started.</p>
<h2 id="writing-actions-using-helpers"><a class="header" href="#writing-actions-using-helpers">Writing actions using helpers</a></h2>
<p>There are five helper functions for writing common actions:</p>
<ul>
<li><code>key_handler</code>: this one is the most general. It wraps a function that takes a
mutable reference to the current window manager state and a reference to the
<code>XConn</code> used by your window manager and runs whatever custom code you care to
write.</li>
<li><code>modify_with</code>: for calling <code>pure</code> state methods this helper handles the diff
and refresh cycle for you. Simply update the <code>StackSet</code> with whatever changes
you want to make and a refresh will be triggered for you to reflect you changes
to the X server.</li>
<li><code>send_layout_message</code>: this does pretty much what you'd expect. It calls the
given function to construct a <code>Message</code> and sends it to the active layout.
(Useful for updating your layout behaviour on the fly).</li>
<li><code>broadcast_layout_message</code>: does the same thing as <code>send_layout_message</code> only
in this case the message is copied and sent to <em>all</em> layouts available to the
current workspace rather than just the active one.</li>
<li><code>spawn</code>: as the name implies, this spawns a given program as a subprocess.
You probably want at least one key binding for spawning either a terminal or
a program launcher such as <code>dmenu</code> or <code>rofi</code>. For the programs you use the
most, this lets you get to them with a single key press!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<p>Currently, penrose offers a single piece of built in UI via the <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/index.html">penrose_ui</a> crate:
a status bar. The bar is inspired by the <code>dwm</code> status bar and provides a simple API
for writing your own text based <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/bar/widgets/trait.Widget.html">widgets</a> for rendering to the screen.</p>
<p>In addition to the widgets described below there are a couple of debugging based widgets
which are useful when trying to diagnose issues with the window manager state but probably
<em>not</em> something you want on your screen all the time. If you are interested in taking a
look at them they can be found <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/bar/widgets/debug/index.html">here</a></p>
<h2 id="the-text-widget"><a class="header" href="#the-text-widget">The Text widget</a></h2>
<p>For building up simple widgets there is the <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/bar/widgets/struct.Text.html">Text</a> widget which can be used to
provide most of the layout and re-render logic with an easy to use API. Any time the
contents of the widget are modified it will be re-rendered to the bar. On its own this
isn't particularly useful but you can add hooks to set the content in response to changes
in the window manager state (which we'll take a look at in the next section).</p>
<p>Text widgets are left justified by default but this can be switched to right justified if
desired. There is also the ability to specify that the widget is <code>greedy</code> which will cause
it to take up any available left over space once all other widgets have finished laying
out their contents. Personally I use this with the <code>ActiveWindowName</code> widget to take up
the middle of the status bar and act as a sort of active screen indicator .</p>
<h2 id="the-refreshtext-widget"><a class="header" href="#the-refreshtext-widget">The RefreshText widget</a></h2>
<p>If you want to render something that doesn't depend on the internal state of the window
manager (such as the current time, volume, connected wifi network etc) then you can set up
a very minimal widget quickly using <code>RefreshText</code>. All you need is a function that returns
the string to be rendered when it is called and the styling you'd like to use when rendering.
From that you get a widget that will check if it needs to re-render every time the internal
window manager state is refreshed and re-render any time the output of your function changes.</p>
<p>The <code>sys</code> module has a number of simple widgets of this nature that you can use as a reference
to get you started. For example, this is all you need to display the current date and time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use penrose::util::spawn_for_output_with_args;
use penrose_ui::bar::widgets::{RefreshText, TextStyle};

pub fn current_date_and_time(style: &amp;TextStyle) -&gt; RefreshText {
    RefreshText::new(style, || {
        spawn_for_output_with_args("date", &amp;["+%F %R"])
            .unwrap_or_default()
            .trim()
            .to_string()
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-widgets"><a class="header" href="#built-in-widgets">Built in widgets</a></h2>
<h3 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h3>
<p>The <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/bar/widgets/struct.Workspaces.html">Workspaces</a> widget is the most complicated built in widget on offer. It checks the
currently available workspaces and several properties about each one:</p>
<ul>
<li>The tag assigned to the workspace</li>
<li>Whether or not the workspace is focused (and on what screen)</li>
<li>If there are any windows visible on the workspace</li>
</ul>
<p>From that it will generate a workspace listing with highlighting to indicate the current
state of your window manager. Workspaces with windows present are assigned a different
foreground color and focused workspaces are assigned a different background color. The
active workspace is indicated with its own highlight for visibility as well.</p>
<h3 id="rootwindowname"><a class="header" href="#rootwindowname">RootWindowName</a></h3>
<p>The <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/bar/widgets/struct.RootWindowName.html">RootWindowName</a> widget is an idea lifted directly from dwm: any time the root window
name is updated it will re-render with its content set to the new name. The <a href="https://man.archlinux.org/man/xsetroot.1.en">xsetroot</a>
tool can be used to set the root window name to whatever string you like and typically
this is used by spawning a shell script that updates the root window name with system
stats on an interval:</p>
<pre><code class="language-sh"># Set the root window name to the current date and time
$ xsetroot -name "$(date '+%F %R')"
</code></pre>
<h3 id="activewindowname"><a class="header" href="#activewindowname">ActiveWindowName</a></h3>
<p>In a similar way, <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/bar/widgets/struct.ActiveWindowName.html">ActiveWindowName</a> will display the title of the currently focused
window. Given that there is less control over what the contents of this string will be,
this widget allows you to set a maximum character count after which the title is
truncated to <code>...</code>.</p>
<p>This widget will also only render on the active screen so it works well as a visual
indicator of which screen currently has focus.</p>
<h3 id="currentlayout"><a class="header" href="#currentlayout">CurrentLayout</a></h3>
<p>The <a href="https://sminez.github.io/penrose/rustdoc/penrose_ui/bar/widgets/struct.CurrentLayout.html">CurrentLayout</a> widget simply calls the <code>layout_name</code> method on the active workspace
each time the internal state is refreshed. Each <code>Layout</code> is free to specify whatever name it
choses so if you want to customise the text displayed by this widget you will need to write a
<code>LayoutTransformer</code> that intercepts the inner name and maps it to your preferred string
instead (or write a new widget that bakes that behaviour into the widget itself).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>An extension is some piece of user written code that works with the penrose APIs to provide some
additional functionality. For specific, common use cases there are a number of traits and helper
functions that are available to do most of the heavy lifting (see the <a href="extensions/../builtin/index.html">builtin</a> section of this
book for examples of what is on offer). For things that are a little more custom, you'll want to
make use of the lower level <code>Hook</code> and <code>State Extension</code> APIs.</p>
<p>This section of the book gives an overview of the different APIs that are on offer and goes into
a little bit of detail around a couple of the commonly requested pieces of functionality that
penrose implements using them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks"><a class="header" href="#hooks">Hooks</a></h1>
<p>Penrose offers several <code>Hooks</code> for you to add custom logic into the existing window manager
logic in order to customise its behaviour. Each type of hook is covered in the following
pages and further details of how new hooks can be written are discussed in the Reference
Guide section later in the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="startup-hooks"><a class="header" href="#startup-hooks">Startup Hooks</a></h1>
<p>Startup hooks are run a single time after you call the <a href="https://sminez.github.io/penrose/rustdoc/penrose/core/struct.WindowManager.html#method.run">run</a> method on the <code>WindowManager</code> struct.
This takes before entering the main event loop but after all other setup has taken place. Any startup
actions you need to take that require the interaction with the X server or manipulating the window manager
state need to placed in here as a <a href="https://sminez.github.io/penrose/rustdoc/penrose/core/hooks/trait.StateHook.html">StateHook</a> (completely custom code independent of the window manager
or X server can be run in your <code>main.rs</code> instead if you prefer).</p>
<p>The <a href="https://sminez.github.io/penrose/rustdoc/penrose/core/struct.Config.html#method.compose_or_set_startup_hook">compose_or_set_startup_hook</a> method on <code>Config</code> can be used to compose together multiple startup
hooks if you are making use of other extensions that also need to set one.</p>
<blockquote>
<p><strong>NOTE</strong>: it is always best to use this method for setting additional hooks after you have created you
initial <code>Config</code> struct in order to avoid accidentally replacing an existing hook!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-hooks"><a class="header" href="#event-hooks">Event Hooks</a></h1>
<p><a href="https://sminez.github.io/penrose/rustdoc/penrose/core/hooks/trait.EventHook.html">EventHooks</a> run before each event from the X server is processed, allowing you to provide your
own custom handling of events. You are free to run whatever code you want in response to events
and you are also able to decide whether or not the built-in event handling should run after you
are done: if you return <code>Ok(true)</code> from your hook then the processing will continue, if you return
<code>Ok(false)</code> then it will stop.</p>
<p>If you <em>do</em> decide to skip default handling you should check carefully what it is that you are
skipping. The main event handling logic can be found <a href="https://github.com/sminez/penrose/blob/develop/src/core/handle.rs">here</a> in the core module.</p>
<p>As with the other hooks, there is a <a href="https://sminez.github.io/penrose/rustdoc/penrose/core/struct.Config.html#method.compose_or_set_event_hook">compose_or_set</a> method on <code>Config</code> to help you combine
multiple event hooks together without accidentally overwriting anything along the way.</p>
<blockquote>
<p><strong>NOTE</strong>: EventHooks are run <em>in order</em> and the first hook to say that no further processing
should take place will short circuit any remaining composed event hooks and the default handling!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manage-hooks"><a class="header" href="#manage-hooks">Manage Hooks</a></h1>
<p><a href="https://sminez.github.io/penrose/rustdoc/penrose/core/hooks/trait.ManageHook.html">ManageHooks</a> allow you to modify how a window is initially added to the window manager state when
it first appears. For example you might move the client to a specific workspace or position in the
stack, or you might mark it as floating in a certain position on the screen. Your hook will be called
after the window has been added into the internal state so the full set of APIs will be available for
you to make use of.</p>
<p>Again, as with the other hooks there is a [compose_or_set][2] method on <code>Config</code> to help you combine
multiple manage hooks together without accidentally overwriting anything along the way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refresh-hooks"><a class="header" href="#refresh-hooks">Refresh Hooks</a></h1>
<p>Refresh hooks (like startup hooks) are added to your window manager as an implementation of the <a href="https://sminez.github.io/penrose/rustdoc/penrose/core/hooks/trait.StateHook.html">StateHook</a> trait.
They are run at the end of the <a href="https://sminez.github.io/penrose/rustdoc/penrose/x/trait.XConnExt.html#method.modify_and_refresh">modify_and_refresh</a> method of the <code>XConnExt</code> trait each time the internal state of
the window manager is refreshed and rendered to the X server. This is one of the more general purpose hooks available
for you to make use of and can be used to run code any time something changes in the internal state of your window
manager.</p>
<blockquote>
<p><strong>NOTE</strong>: Xmonad refers to this as a "Log Hook" which I find a little confusing. The name comes from the fact that
one of the main use cases is to log the internal state of the window manager in order to update a status bar, which
makes sense but I prefer naming the hooks for where they are called in the event handling flow.</p>
</blockquote>
<p>As with the other hooks, there is a <a href="https://sminez.github.io/penrose/rustdoc/penrose/core/struct.Config.html#method.compose_or_set_refresh_hook">compose_or_set</a> method on <code>Config</code> for adding Refresh Hooks into you existing
<code>Config</code> struct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ewmh"><a class="header" href="#ewmh">EWMH</a></h1>
<p>Support for <a href="https://specifications.freedesktop.org/wm-spec/latest/">EWMH</a> in penrose is provided (surprisingly enough) via the <a href="https://sminez.github.io/penrose/rustdoc/penrose/extensions/hooks/ewmh/index.html">ewmh</a> module
in <code>extensions</code>. This provides minimal support for floating windows and setting the appropriate
properties for interaction with things like external status bars (<code>polybar</code> for example).</p>
<p>The <a href="https://sminez.github.io/penrose/rustdoc/penrose/extensions/hooks/ewmh/fn.add_ewmh_hooks.html">add_ewmh_hooks</a> function can be applied to an existing <code>Config</code> in order to set up the
required hooks for adding this support.</p>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="overview-of-concepts"><a class="header" href="#overview-of-concepts">Overview of Concepts</a></h1>
<p>Penrose is a <a href="https://wiki.archlinux.org/title/Window_manager">dynamic tiling window manager</a> for <a href="https://wiki.archlinux.org/title/Xorg">Xorg</a> in the spirit of <a href="https://xmonad.org/">Xmonad</a>. Most of the
concepts and APIs you'll find for penrose are nothing new, but if you plan on digging into writing your
own window manager then it's worthwhile taking a bit of time to learn what all the moving parts are.</p>
<p>At its core, the main operation of penrose is an event loop that reacts to events received from the X
server. In simplified rust code, it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let event = get_next_xevent();
    match event {
        // for each event type run the appropriate handler
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There's obviously more to it than that, but this is a pretty good starting point for how to think about
your window manager. Penrose provides a number of different ways to modify how the default handling
of events behaves and for running custom code in response to key presses. The pages in this section of
the book each cover (at a relatively high level) what the moving parts that make this work all look like.</p>
<p>First up: pure code vs X code.</p>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="pure-code-vs-x-code"><a class="header" href="#pure-code-vs-x-code">Pure Code vs X Code</a></h1>
<p>Writing a window manager presents a rather large problem for implementing and maintaining a codebase,
namely that you need an X server running in order to run code that talks to an X server... The approach
penrose takes to solving this issue (primarily for being able to write tests) is shamelessly stolen
from Xmonad: split the code base in two.</p>
<p>On one side we have "pure" rust code that manipulates internal data structures representing the logical
state of the window manager (known clients, which screen they are on, where on that screen they are
positioned etc) and on the other side we have code that submits requests to (and receives events from)
the X server. The two sides meet inside of the <code>modify_and_refresh</code> method of the <code>XConnExt</code> trait.</p>
<h3 id="working-with-diffs"><a class="header" href="#working-with-diffs">Working with diffs</a></h3>
<p>The primary way that most X actions are generated by penrose is through this <code>modify_and_refresh</code> method.
It computes a diff of the "pure" window manager state before and after some mutating operation in order
to determine what changes need to be reflected in the X server state. For example:</p>
<ul>
<li>Focus has moved to a new window</li>
<li>A new window has been created</li>
<li>The active workspace has switched to a new layout algorithm</li>
<li>A new screen has been detected</li>
<li>...</li>
</ul>
<p>You get the idea.</p>
<p>Doing things this way lets penrose decouple the logical operations you want to carry out (and test!)
from the X side effects needed to actually <em>do</em> something on screen. This isn't a full, capital <strong>M</strong>
monad in the style of Xmonad but it's pretty good for our purposes without getting snarled up in a
lot of type theory. Another way to think of this is as a <em>render</em> of internal state changes out to
the X server much like you would see in a GUI library or front end web framework.</p>
<p>What you'll see in practice, is that most operations that you want to perform in penrose are handled
by calling a method on one of the <code>pure</code> data structures inside of a call to <code>modify_and_refresh</code>.
The methods themselves are nice and easy to test and have confidence in, and the complexity of
managing the X state is confined to one part of the code base that is then a lot easier to audit and
maintain.</p>
<h3 id="triggering-a-refresh-directly"><a class="header" href="#triggering-a-refresh-directly">Triggering a refresh directly</a></h3>
<p>There are of course, times when you need to do something a <em>little</em> more involved that requires you
to make some requests to the X server yourself as part of some otherwise pure logic. You might need
to check (or set) a property on a client window for example. In those cases, you can call the
<code>refresh</code> method after carrying out whatever combination of pure and X related actions you need to
perform. Internally, penrose tracks a snapshot of the previous pure state each time a refresh takes
place so you always have <em>something</em> to compute the diff against.</p>
<blockquote>
<p>Just be careful to remember that none of the pure state changes will be reflected in the "real"
X server state until a refresh takes place! Depending on how complicated your logic is you may
need multiple refreshes to get what you are after (but if you find yourself doing this it's
probably an indicator that you should raise an issue in GitHub to see if there is a simpler
way to achieve what you are after).</p>
</blockquote>
<p>Given that it's the easier to reason about side of things, lets kick things off with a look at the
data structures that make up the <code>pure</code> side of the penrose APIs.</p>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<p>As mentioned in <a href="overview/./pure-vs-x.html">Pure Code vs X Code</a>, there are a number of <code>pure</code> data structures that penrose makes use of
in order to manage the internal state of the window manager. We wont get too much into the details of all of the
various methods associated with each data structure: for that it's best to read the docs on docs.rs. Instead,
we'll take a quick look at what each data structure does and how you can make use of it when writing your own
penrose based window manager.</p>
<p>Most of the data structures outlines below are some form of <a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)">zipper</a> (or some meta-data wrapped around a zipper).
If the Wikipedia page all looks a bit "computer science-y" to you then you can get by pretty well by thinking of
a zipper as collection type (like a list or a tree) that has an added concept of "focus" (that is, "the element
of the collection we are currently looking at"). There is a really nice article about <a href="https://donsbot.com/2007/05/17/roll-your-own-window-manager-tracking-focus-with-a-zipper/">the use of zippers in Xmonad</a>
which is worth a read if you have the time. It covers the starting point for the use of zippers in penrose and
also shows where all of the names come from(!) Penrose takes the idea a little further than what is seen in
Xmonad in order to provide what I think is a nicer API to work with (but I'll let you be the judge of that).</p>
<p>First up, the arguably incorrectly named "Stack".</p>
<h3 id="stacks"><a class="header" href="#stacks">Stacks</a></h3>
<p>So called because it (primarily) represents the X "window stack" for the current screen you are looking at. Getting
technical for a minute, a <code>Stack</code> is a zipper over a <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">doubly-linked list</a> that has a couple of nice properties
that help to simplify how a lot of the rest of the code in penrose is written:</p>
<ol>
<li>A Stack is <em>never</em> empty (there is always at least the focused element)</li>
<li>Operations that manipulate which element is focused do not alter the <em>order</em> of the elements themselves.</li>
<li>Operations that work with the focused element are <code>O(1)</code></li>
</ol>
<p>You can think of a <code>Stack</code> as simply being a normal linked list with a flag on one of the elements to indicate
where the focus point currently sits. (The actual implementation is a little different in order to make things
nicer to work with but the idea itself is fine).</p>
<p>Penrose makes use of <code>Stacks</code> for anything that we want to track focus for. Specifically, we use them for tracking:</p>
<ul>
<li>windows assigned to each workspace</li>
<li>the layouts in use on each workspace</li>
<li>workspaces assigned to a each screen</li>
</ul>
<p>The operations available on <code>Stacks</code> are pretty much what you'd expect: you can treat them like collections (map,
filter, re-order the elements, iterate, etc) and you can move the focus point around.</p>
<h3 id="workspaces-1"><a class="header" href="#workspaces-1">Workspaces</a></h3>
<p>Up next after <code>Stacks</code> is <code>Workspaces</code>. You can think of a workspace as a wrapper around a given window stack that
helps penrose know how to locate the given stack of clients and how (and when) to position them on the screen.
Rust type wise, a workspace look like this (the fields on a real <code>Workspace</code> aren't public but we can ignore that for now):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Workspace {
    id: usize,
    tag: String,
    layouts: Stack&lt;Layout&gt;,
    stack: Option&lt;Stack&lt;Xid&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>id</code> and <code>tag</code> fields are used to identify workspaces within the larger pure state: useful, but not particularly
interesting. The client <code>Stack</code> itself is wrapped in an Option because (like we mentioned above) there is no such
thing as an empty <code>Stack</code>, so a <code>Workspace</code> with no windows has <code>None</code>. Running operations on the stack contained in
a given workspace is possible from the top level of the pure state (which we'll cover in a bit).</p>
<p>The <code>layouts</code> field contains all of the possible <a href="overview/./layouts.html">Layout</a> algorithms available for positioning windows on this
workspace. There must be at least one layout available (so no <code>Option&lt;Stack&gt;</code> here) and the currently focused layout
in the stack is the one that will be used to position windows when this workspace is placed on a given screen.</p>
<p>Speaking of which...</p>
<h3 id="screens"><a class="header" href="#screens">Screens</a></h3>
<p>If you thought a <code>Workspace</code> was pretty much "a window Stack with a fancy hat", then a <code>Screen</code> is "a Workspace in a
box".</p>
<p>A 2D box to be precise.</p>
<p>For the purposes of our pure state, all we care about when it comes to the physical screens we have to play with are:</p>
<ul>
<li>which screen we're talking about</li>
<li>the dimensions of the screen</li>
<li>the workspace that is currently active</li>
</ul>
<p>Each screen pairs a <code>Workspace</code> with an ID (<code>0..n</code> in the order that they are returned to us by the X server) and a
<code>Rect</code> to denote the size and relative position of each screen in pixels. Workspaces can be moved between screens,
clients can be moved between workspaces.</p>
<p>Lovely.</p>
<h4 id="rectangles"><a class="header" href="#rectangles">Rect(angles)</a></h4>
<p>Both screens and the windows that sit within them are described using rectangles. Each <code>Rect</code> is simply the <code>(x, y)</code>
coordinates of its top left corner along with its width and height. Not <em>massively</em> exciting on its own but it's
worth taking a look at the docs on the <code>Rect</code> struct to see what methods are available for slicing, dicing, positioning
and comparing Rects while you write your custom Layout algorithms and extensions.</p>
<h3 id="the-stackset"><a class="header" href="#the-stackset">The StackSet</a></h3>
<p>And last but by no means least, we have the <code>StackSet</code>. It's a <em>little</em> "set-y" when you break it down so that's what
we're going for name wise until someone gives me something better (it's definitely a lot <em>more</em> like a set than the
original from Xmonad in my opinion but we'll get to that in a second).</p>
<p>Ignoring several book-keeping fields which we maintain for quality of life purposes, the Rust type looks something like
this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StackSet {
    screens: Stack&lt;Screen&gt;,
    hidden: LinkedList&lt;Workspace&gt;,
    // and some book-keeping...
}
<span class="boring">}</span></code></pre></pre>
<p>I'm not quite sure how best to describe what's going on here in terms of Zippers as it's a <em>little</em> bit of an abuse of
the concept but, if you squint hard enough, what you're looking at is pretty much a "Stack of Stacks". Albeit with a
healthy sprinkling of meta-data throughout and the fact that for the unfocused elements we don't care about their order
(hence the <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">set</a> based name).</p>
<p>If you think back to what we said a <code>Zipper</code> was, we said we had some collection of elements along with the idea of there
being a "focus point" that picks out an element from that collection. For the <code>StackSet</code>, the collection is a set of
<code>Workpsaces</code>, and the "focus" is actually a <code>Stack</code> of <code>Screens</code> and their <em>associated</em> <code>Workspaces</code>.</p>
<p>...still with me?</p>
<p>If you think about what we care about when managing windows, we can break things down into the following:</p>
<ul>
<li>The windows we are managing (<code>Stacks</code>)</li>
<li>The workspaces those windows are assigned to (<code>Workspaces</code>)</li>
<li>The screens those workspaces are shown on (<code>Screens</code>)</li>
<li>The workspaces that are currently hidden from view (more <code>Workspaces</code>)</li>
</ul>
<p>For the workspaces that are visible, we move them in and out of the available screens as needed and we maintain the
currently focused screen which is where the X input focus currently lies. For the hidden workspaces we don't really care
about what order they are in (we can't see them) so we use a LinkedList to store anything not currently allocated to a
screen.</p>
<blockquote>
<p>We <em>could</em> use a <code>HashSet</code> but then we'd need Workspaces to be hashable and it doesn't actually buy us much in terms
of the API we end up with.</p>
</blockquote>
<p>Having the focused "element" be another level of wrapping around <em>multiple</em> element from the collection really pushes
the definiton of a Zipper I suspect but it works pretty nicely all things considered. We can then fully manage the
on screen position and stack position of each window and manipulate groups of windows based on the workspace they are
part of.</p>
<p>Nice.</p>
<h3 id="and-thats-it"><a class="header" href="#and-thats-it">And that's it!</a></h3>
<p>Admittedly, "it" is a rather large set of methods on a <code>StackSet</code> but it gives you a rich, zipper based API for manipulating
your windows which handles all of the focus book-keeping for you. To really understand everything that is possible with
the API it is best to dive into the docs.rs docs and try things out for yourself. The <em>real</em> structs are generic rather
than having to contain <code>Xids</code> as shown in the pseudo-code above so feel free to pull in penrose as a dependency and start
having a play with them to see what is possible!</p>
<p>The tests suites are another good place to take a look at how things work without getting too tied up in the specific use
cases penrose has for things.</p>
<p>Speaking of specifics, lets take a look at how to actually do useful things with your window manager: up next we're covering
layouts.</p>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="building-on-top-of-penrose"><a class="header" href="#building-on-top-of-penrose">Building on top of penrose</a></h1>
<p>Out of the box, the examples provided in the penrose GitHub repository show you how to put
together a fairly minimal window manager. By design, penrose does not attempt to implement
every piece of functionality you might like from your favourite window manager, instead it
provides a set of rich, composable APIs for extending the behaviour and adding your own
custom logic.</p>
<p>The simplest place to start is with running custom code in response to key bindings, whether
that's to modify how your windows are arranged on the screen, to launch a new program or
run completely custom logic. From there you can dig into things like custom layout algorithms
and extending the core window manager behaviour with hooks.</p>
<blockquote>
<p>If you've ever experimented with Xmonad or Qtile before then the set up should feel
somewhat familiar to you.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="actions-1"><a class="header" href="#actions-1">Actions</a></h1>
<p>To start with we're going to assume that when we talk about running an <code>Action</code> we're talking about
executing some custom code in response to a key binding bein pressed. With that in mind, lets take
a look at the <a href="https://sminez.github.io/penrose/rustdoc/penrose/core/bindings/trait.KeyEventHandler.html">KeyEventHandler</a> trait found in <code>penrose::core::bindings</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait KeyEventHandler&lt;X: XConn&gt; {
    fn call(&amp;mut self, state: &amp;mut State&lt;X&gt;, x: &amp;X) -&gt; Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>There's not much to it: you are given mutable access to the window manager <code>State</code> and a reference to
the X connection. From there you can do pretty much whatever you like other than return data (we'll
take a look at how you can persist and manage your own state in a bit!)</p>
<p>To make things easier to work with (and to avoid having to implement this trait for every piece of
custom logic you want to run) there are several helper functions provided for wrapping free functions
of the right signature.</p>
<blockquote>
<p><strong>NOTE</strong>: In any case where you do not need to manage any additional state, it is <em>strongly</em>
recommended that you make use of these helpers to write your actions as simple functions rather
than structs that implement the <code>KeyEventHandler</code> trait.</p>
</blockquote>
<h2 id="built-in-helpers"><a class="header" href="#built-in-helpers">Built-in helpers</a></h2>
<p>In the <a href="https://sminez.github.io/penrose/rustdoc/penrose/builtin/actions/index.html">penrose::builtin::actions</a> module you will find a number of helper functions for writing
actions. The most general of these being <code>key_handler</code> which simply handles plumbing through the
required type information for Rust to generate the <code>KeyEventHandler</code> trait implementation for you.</p>
<h3 id="an-example"><a class="header" href="#an-example">An example</a></h3>
<p>As a real example of how this can be used, here is the power menu helper I have in my own set up
which makes use of the dmenu based helpers in <a href="https://sminez.github.io/penrose/rustdoc/penrose/extensions/util/dmenu/index.html">penrose::extensions::util::dmenu</a> to prompt the
user for a selection before executing the selected action:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use penrose::{
    builtin::actions::key_handler,
    core::bindings::KeyEventHandler,
    custom_error,
    extensions::util::dmenu::{DMenu, DMenuConfig, MenuMatch},
    util::spawn,
};
use std::process::exit;

pub fn power_menu&lt;X: XConn&gt;() -&gt; KeyEventHandler&lt;X&gt; {
    key_handler(|state, _| {
        let options = vec!["lock", "logout", "restart-wm", "shutdown", "reboot"];
        let menu = DMenu::new("&gt;&gt;&gt; ", options, DMenuConfig::default());
        let screen_index = state.client_set.current_screen().index();

        if let Ok(MenuMatch::Line(_, choice)) = menu.run(screen_index) {
            match choice.as_ref() {
                "lock" =&gt; spawn("xflock4"),
                "logout" =&gt; spawn("pkill -fi penrose"),
                "shutdown" =&gt; spawn("sudo shutdown -h now"),
                "reboot" =&gt; spawn("sudo reboot"),
                "restart-wm" =&gt; exit(0), // Wrapper script then handles restarting us
                _ =&gt; unimplemented!(),
            }
        } else {
            Ok(())
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p>The window manager state is used to determine the current screen (where we want to open dmenu)
but other than that we're running completely arbitrary code in response to a keypress. The main
thing to keep in mind is that penrose is <em>single threaded</em> so anything you do in an action must
complete in order for the event loop to continue running.</p>
<h3 id="stackset-manipulation"><a class="header" href="#stackset-manipulation">StackSet manipulation</a></h3>
<p>The most common set of actions you'll want to perform are modifications to the <code>StackSet</code> in
to reposition and select windows on the screen. There are <a href="https://sminez.github.io/penrose/rustdoc/penrose/pure/struct.StackSet.html">a large number of methods</a> available
for modifying the current state of your windows and the <a href="https://sminez.github.io/penrose/rustdoc/penrose/builtin/actions/fn.modify_with.html">modify_with</a> helper gives you an
easy way to call them directly. If you think back to the minimal example window manager we covered
in the "getting started" section, we saw this in use for most of the key bindings. Paraphrasing
a little, it looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use penrose::builtin::actions::modify_with;

// Select the next available layout algorithm
modify_with(|cs| cs.next_layout());

// Close the currently focused window
modify_with(|cs| cs.kill_focused());
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="layouts-2"><a class="header" href="#layouts-2">Layouts</a></h1>
<p>Layouts are (lets face it) a large part of why people use a dynamic tiling window manager in the first place.
You want to automatically manage your windows in a way that either lets you get on with what you're doing, or
looks fun and interesting!</p>
<p>For penrose, layouts are implemented using a trait that lets you specify how the layout should be applied and
manage any additional state you might need. They also support custom messages being sent to modify their
behaviour and update that state: another shamelessly re-used idea from Xmonad. You may be starting to spot a
pattern here...</p>
<h3 id="taking-a-look-at-the-layout-trait"><a class="header" href="#taking-a-look-at-the-layout-trait">Taking a look at the Layout trait</a></h3>
<p>Other than a few pieces of housekeeping (providing a string name to be used to identify the layout and some
plumbing to help with dynamic typing) the <code>Layout</code> trait is primarily several methods that give you (the
implementer) some flexability in how you want to approach positioning your windows and how what level of
customisation you want to give the user while the window manager is running:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Layout {
    fn name(&amp;self) -&gt; String;
    fn boxed_clone(&amp;self) -&gt; Box&lt;dyn Layout&gt;;

    fn layout_workspace(
        &amp;mut self,
        tag: &amp;str,
        stack: &amp;Option&lt;Stack&lt;Xid&gt;&gt;,
        r: Rect
    ) -&gt; (Option&lt;Box&lt;dyn Layout&gt;&gt;, Vec&lt;(Xid, Rect)&gt;);

    fn layout(
        &amp;mut self,
        s: &amp;Stack&lt;Xid&gt;,
        r: Rect
    ) -&gt; (Option&lt;Box&lt;dyn Layout&gt;&gt;, Vec&lt;(Xid, Rect)&gt;);
    
    fn layout_empty(
        &amp;mut self,
        r: Rect
    ) -&gt; (Option&lt;Box&lt;dyn Layout&gt;&gt;, Vec&lt;(Xid, Rect)&gt;);

    fn handle_message(&amp;mut self, m: &amp;Message) -&gt; Option&lt;Box&lt;dyn Layout&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>On the "laying out windows" front (you know, the main one) you have three choices:</p>
<ul>
<li>Specify how to layout a possibly empty workspace based on the specific tag being laid out</li>
<li>Specify how to layout a given (non-empty) stack of clients for any workspace</li>
<li>Specify what to do when there are no clients present on the given workspace</li>
</ul>
<p>Both <code>layout_workspace</code> and <code>layout_empty</code> have default implementations that should work in 99% of cases,
leaving you the job of writing <code>layout</code>: how a given screen <code>Rect</code> should be split up between a given
<code>Stack</code> of client windows. That said, if you <em>do</em> want to specify how to layout particular workspaces or
give some custom logic that should run when a workspace is empty, both default implementations are of course
overridable.</p>
<blockquote>
<p>If you haven't read it already, it's worthwhile taking a look at the <a href="building/./data-structures.html">data structures</a> section of this
book to familiarise yourself with the types being discussed here!</p>
</blockquote>
<h3 id="writing-a-layout-function"><a class="header" href="#writing-a-layout-function">Writing a layout function</a></h3>
<p>At it's core, a layout function is pretty simple: for a given region of screen real estate, assign sub-regions
to any number of the clients present on the workspace. There are no requirements to position <em>every</em> client
and there are no requirements that clients do not overlap. There's just one key piece of information to bear
in mind:</p>
<blockquote>
<p><em>The order that you return your positions in is the order that the windows will be stacked from top to bottom</em>.</p>
</blockquote>
<p>If none of the <code>Rects</code> you return overlap then this doesn't matter all that much, but if you <em>do</em> care about
stacking order, make sure to return your positions in order of top to bottom. Positions themselves are simply a
tuple of <code>(Xid, Rect)</code>. Any client window present in the provided <code>Stack</code> that you do not assign a position will
be unmapped from the screen.</p>
<p>As a simple example, here is the definition (in full) of the <code>Monocle</code> layout from the <code>builtin</code> module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]
pub struct Monocle;

impl Layout for Monocle {
    fn name(&amp;self) -&gt; String {
        "Mono".to_owned()
    }

    fn boxed_clone(&amp;self) -&gt; Box&lt;dyn Layout&gt; {
        Box::new(Monocle)
    }

    fn layout(&amp;mut self, s: &amp;Stack&lt;Xid&gt;, r: Rect) -&gt; (Option&lt;Box&lt;dyn Layout&gt;&gt;, Vec&lt;(Xid, Rect)&gt;) {
        (None, vec![(s.focus, r)])
    }

    fn handle_message(&amp;mut self, _: &amp;Message) -&gt; Option&lt;Box&lt;dyn Layout&gt;&gt; {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Pretty simple right? Admittedly, this is about as simple as you can make it (the focused window gets the
full screen and everything else gets unmapped) but the overall boilerplate is kept to a minimum, which
is nice.</p>
<blockquote>
<p><strong>NOTE</strong>: The <code>builtin</code> module has some good examples of what a "real" layout looks like (not to dunk
on <code>Monocle</code> but...come on). Why not take a look at <code>MainAndStack</code> as a starting point for how to write
something a little more interesting?</p>
</blockquote>
<p>But, I hear you cry (silently, through the internet) those <code>layout_*</code> methods don't just return a
<code>Vec&lt;(Xid, Rect)&gt;</code> do they? They also return an <code>Option&lt;Box&lt;dyn Layout&gt;&gt;</code>. What's up with that?</p>
<p>I'm so glad you asked.</p>
<h4 id="swapping-things-out-for-a-new-layout"><a class="header" href="#swapping-things-out-for-a-new-layout">Swapping things out for a new layout</a></h4>
<p>Depending on how fancy you want to get with your layout behaviour, you might find yourself wanting to switch
things out to a new <code>Layout</code> implementation after you've positioned a stack of client windows for a particular
screen. Maybe you want to swap things out for a different layout depending on the number of clients, or the
screen size, or whether the width of the screen is a multiple of 7, or maybe you want the layout to change each
time it gets applied. Who knows! The point is, if you <em>do</em> find yourself needing to swap things out this is a
way for you to do it.</p>
<p>In most cases you'll simply want to return <code>None</code> as the first value in the tuple being returned from layout
methods, but if you instead return <code>Some(new layout)</code>, penrose will swap out your current layout for the new
one.</p>
<p>If instead you just want to update some internal state in response to an explicit trigger, that's where <code>Messages</code>
come in.</p>
<h3 id="handling-messages"><a class="header" href="#handling-messages">Handling messages</a></h3>
<p><code>Messages</code> are a way of sending dynamically typed data to your layouts in order to update their state. A message
can be <a href="https://doc.rust-lang.org/std/any/trait.Any.html">literally anything</a> so long as it implements the <code>IntoMessage</code> trait, which is as simple as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoMessage for MyMessage {}
<span class="boring">}</span></code></pre></pre>
<p>What any given message actually <em>does</em> is entirely at the discression of the <code>Layout</code> that handles it. So far,
so vague...lets take a look at an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use penrose::core::layout::{IntoMessage, Layout, Message};

// First we define our message and implement the marker trait
struct SetFrobs(pub usize);
impl IntoMessage for SetFrobs {}

// Next we write our layout
struct MyLayout {
    frobs: usize,
}

impl Layout for MyLayout {
    // TODO: actually write the layout(!)

    fn handle_message(&amp;mut self, m: &amp;Message) -&gt; Option&lt;Box&lt;dyn Layout&gt;&gt; {
        // If the Message is a 'SetFrobs' we'll do what it says on the tin...
        if let Some(&amp;SetFrobs(frobs)) = m.downcast_ref() {
            self.frobs = frobs;
        }

        // ...and anything else we can just ignore

        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>downcast_ref</code> method is the thing to pay attention to here: this is how we go from a <code>Message</code> (really just
a wrapper around the standard library <code>Any</code> trait) to a concrete type. Anything that implements <code>IntoMessage</code>
can be sent to our Layout so we do our own type checking to see if the message is something we care about. Messages
that we don't handle can safely be dropped on the floor (so don't worry about needing to exhaustively check all
possible message types).</p>
<p>The <code>Option&lt;Box dyn Layout&gt;</code> return type is the same idea as with the <code>layout_*</code> methods covered above: in response
to a message you can swap out to a new layout. Say hypothetically, there was a frob threshold above which things
got really awesome...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A more AWESOME layout
struct MyAwesomeLayout {
    frobs: usize,
}

// Which has its own Layout implementation
impl Layout for MyAwesomeLayout {
    // ...
}

const AWESOMENESS_THRESHOLD: usize = 42;

// Now, we modify our impl for MyLayout to "level up" once we hit the threshold
impl Layout for MyLayout {
    // TODO: still need to write the layout at some point...

    fn handle_message(&amp;mut self, m: &amp;Message) -&gt; Option&lt;Box&lt;dyn Layout&gt;&gt; {
        if let Some(&amp;SetFrobs(frobs)) = m.downcast_ref() {
            if frobs &gt; AWESOMENESS_THRESHOLD {
                // Things are getting awesome!
                return Some(Box::new(MyAwesomeLayout { frobs }));
            }

            // Still pretty cool, but not awesome yet...
            self.frobs = frobs;
        }

        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Nice!</p>
<p>That's all well and good if we have a bunch of our own layouts that we can write and swap between, but what if we
just want to <em>tweak</em> an existing layout a bit? Well that's where we move over to the wonderful world of
<code>LayoutTransformers</code>.</p>
<h3 id="layout-transformers"><a class="header" href="#layout-transformers">Layout transformers</a></h3>
<p>This one is a bit of a rabbit hole...for now we'll cover the basics of what you can do with a transformer and leave
the details to the module docs themselves as there's quite a bit to cover!</p>
<p><code>LayoutTransformer</code> is (surprise, surprise) another trait you can implement. It represents a wrapper around an inner
<code>Layout</code> which you (the author of the transformer) get to <del>lie to</del> help reach its full potential. The two main
things that a transformer can do are:</p>
<ul>
<li>Modify the dimensions of the initial <code>Rect</code> being passed to the inner layout</li>
<li>Modify the positions returned by the inner layout before they are handed off for processing</li>
</ul>
<p>So what does that let you do? Well for one thing, this is how gaps are implemented for any layout in penrose. The
<code>Gaps</code> transformer from the <code>builtin</code> module shrinks the size of the initial screen seen by the inner layout (to
give you an outer gap) and then shrinks the size of each window once the layout has run (to give you an inner gap).</p>
<p>For simple cases where you just want to modify the positions returned by an inner layout, there's a handy builtin
macro to generate a <code>LayoutTransformer</code> from a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use penrose::{pure::geometry::Rect, simple_transformer, Xid};

fn my_transformer(r: Rect, positions: Vec&lt;(Xid, Rect)&gt;) -&gt; Vec&lt;(Xid, Rect)&gt; {
    // Write your transformation implementation here
}

simple_transformer!("MyTransform", MyTransformer, my_transformer);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><image width="50px" src="https://raw.githubusercontent.com/sminez/penrose/develop/icon.svg" align="left"></image></p>
<h1 id="penrose-faqs"><a class="header" href="#penrose-faqs">Penrose FAQs</a></h1>
<h2 id="how-do-i-install-penrose"><a class="header" href="#how-do-i-install-penrose">How do I install Penrose?</a></h2>
<p>You don't: Penrose is a library that you use to write your own window manager.
Take a look at the getting started guide for details of how to use Penrose
as a library.
<br><br></p>
<h2 id="where-can-i-view-the-penrose-source-code"><a class="header" href="#where-can-i-view-the-penrose-source-code">Where can I view the Penrose source code?</a></h2>
<p>Penrose is developed openly on <a href="https://github.com/sminez/penrose">GitHub</a> and published to <a href="https://crates.io/crates/penrose">crates.io</a>
periodically as new features are added. The <code>develop</code> branch always has the
latest code and is what I use for running Penrose on my personal laptop. It
is not advised that you pin your use of Penrose to the GitHub <code>develop</code> branch
as a typically end user however: breaking changes (and weird and wonderful bugs)
are highly likely.</p>
<p>You have been warned!
<br><br></p>
<h2 id="how-does-penrose-differ-from-other-tiling-window-managers"><a class="header" href="#how-does-penrose-differ-from-other-tiling-window-managers">How does Penrose differ from other tiling window managers?</a></h2>
<p>Penrose is a tiling window manager <em>library</em> rather than a tiling window
manager. It provides core logic and traits (interfaces) for writing your own
tiling window manager, along with default implementations that can be used out
of the box. That said, you can't <strong>install</strong> Penrose: you need to write your own
Rust <a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">crate</a> that brings in Penrose as a dependency.</p>
<p>The Penrose repository has several up to date examples of what a typical
<code>main.rs</code> ends up looking like and there is a guide on how to go from installing
rust to running Penrose as your window manager located <a href="https://github.com/sminez/penrose/blob/develop/docs/getting_started.md">here</a>
<br><br></p>
<h2 id="does-penrose-support-wayland-as-a-back-end"><a class="header" href="#does-penrose-support-wayland-as-a-back-end">Does Penrose support Wayland as a back end?</a></h2>
<p>Short answer: no.</p>
<p>Long answer:</p>
<p>Wayland merges the concept of the window manager with the that of the
compositor, which results in significantly more work (which I'm not planning on
doing given that I'm perfectly happy with X11 as a back end). The internal APIs
of Penrose only expect to be managing window positioning and workspaces (as far
as X is concerned) so while it <em>may</em> be possibly to add Wayland support, it's
not a simple task. It is definitely something that would be interesting to look
into in the future but it's not a high priority for me personally as I am
perfectly happy running X11 for now.
<br><br></p>
<h2 id="wheres-the-eye-candy"><a class="header" href="#wheres-the-eye-candy">Where's the eye candy?</a></h2>
<p>Short answer: there isn't any.</p>
<p>Long answer:</p>
<p>Penrose is, first and foremost, designed with simplicity, speed and stability in
mind. This means that the default, out of the box offering is pretty minimal.
I'm a big fan of the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">unix philosophy</a> and with that in mind, Penrose largely
restricts its core functionality to managing your windows. Decorations and
animation are not first class citizens but can be added through extensions and
user code if desired.
<br><br></p>
<h2 id="are-you-accepting-contributions-for-open-issues"><a class="header" href="#are-you-accepting-contributions-for-open-issues">Are you accepting contributions for open issues?</a></h2>
<p>Short answer: please discuss on the issue in question</p>
<p>Long answer:</p>
<p>Typically issues in the GitHub issue tracker are already being worked on or are
blocked for some particular reason that should be clear from the issue. If you
would like to work on an open issue that looks to be stalled please add a
comment to the issue in question registering your interest.</p>
<p>If you would like to raise a bug report or make a feature request then please
open a new issue and get confirmation that the change / approach to the fix is
somethat that is likely to be accepted before starting work.
<br><br></p>
<h3 id="can-i-raise-a-pull-request-adding-a-shiny-new-feature"><a class="header" href="#can-i-raise-a-pull-request-adding-a-shiny-new-feature">Can I raise a Pull Request adding a shiny new feature?</a></h3>
<p>Short answer: please raise an issue first to discuss what it is you want to add.</p>
<p>Long answer:</p>
<p>No really, please make sure to raise an issue in GitHub <em>before</em> raising a pull
request in the repo. I'm very happy to accept contributions for both bug fixes
and new functionality but (like most open source maintainers) I do not have time
to review pull requests that have had no prior discussion before being raised.
If there are any issues with the approach being taken (or breaking changes / conflicts
with ongoing work) it can end up with a reasonable amount of back and forth as
changes are requested and made.</p>
<p>Put simply, it's a far better experience for me as a maintainer and you as a
contributor to get a thumbs up on an approach before spending time on the implementation!
<br><br></p>
<h2 id="can-you-add-feature-x-from-this-other-window-manager"><a class="header" href="#can-you-add-feature-x-from-this-other-window-manager">Can you add 'feature X' from this other window manager?</a></h2>
<p>Short answer: probably not as a core feature, but feel free to raise an issue to discuss it.</p>
<p>Long answer:</p>
<p>I started <code>penrose</code> because 1) I like hacking on stuff and it seemed like a fun
idea and 2) I was dissatisfied with the feature sets offered by other window
managers. Some had everything I wanted, but came with things that I really
didn't like, while others felt like they were missing features. <code>penrose</code> has
been written to be a base layer that you can build from to write a window
manager that works how you want it to: this means that there is a small set of
opinionated, core functionality and then a variety of ways to extend this. There
are likely a few pieces of functionality that I have missed that <em>can</em> be added
to core without disrupting what is already there, but most "missing" features
from other window managers are missing on purpose. If you would like to add them
as an extension, please see the contribution guidelines above.</p>
<p>One important category of functionality that will not be added to the core of the
<code>penrose</code> crate itself is any sort of helper program or additional scripts that
aim to wrap <code>penrose</code> and make it look like a stand alone binary.</p>
<p><code>penrose</code> is (as clearly stated in the README) a library, <em>not</em> a binary.</p>
<p>If writing your own crate and compiling and installing the resulting binary is
not something you want to manage and maintain, then <code>penrose</code> is not for you.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
