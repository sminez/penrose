/*! API wrapper for talking to the X server using XCB
 *
 *  The crate used by penrose for talking to the X server is rust-xcb, which
 *  is a set of bindings for the C level XCB library that are autogenerated
 *  from an XML spec. The XML files can be found
 *  [here](https://github.com/rtbo/rust-xcb/tree/master/xml) and are useful
 *  as reference for how the API works. Sections have been converted and added
 *  to the documentation of the method calls and enums present in this module.
 *
 *  [EWMH](https://specifications.freedesktop.org/wm-spec/wm-spec-1.3.html)
 *  [Xlib manual](https://tronche.com/gui/x/xlib/)
 */
use crate::{
    bindings::{KeyBindings, KeyCode, MouseBindings, MouseEvent},
    data_types::{Point, Region, WinId},
    screen::Screen,
    Result,
};

use std::{cell::Cell, collections::HashMap, str::FromStr};

use anyhow::anyhow;
use strum::*;

const WM_NAME: &str = "penrose";

// xcb argument enums
const WINDOW_CLASS_INPUT_ONLY: u16 = xcb::xproto::WINDOW_CLASS_INPUT_ONLY as u16;
const GRAB_MODE_ASYNC: u8 = xcb::GRAB_MODE_ASYNC as u8;
const INPUT_FOCUS_PARENT: u8 = xcb::INPUT_FOCUS_PARENT as u8;
const PROP_MODE_REPLACE: u8 = xcb::PROP_MODE_REPLACE as u8;

// atoms
const ATOM_WINDOW: u32 = xcb::xproto::ATOM_WINDOW;
const ATOM_ATOM: u32 = xcb::xproto::ATOM_ATOM;
const ATOM_CARDINAL: u32 = xcb::xproto::ATOM_CARDINAL;

// window props
const STACK_MODE: u16 = xcb::CONFIG_WINDOW_STACK_MODE as u16;
const STACK_ABOVE: u32 = xcb::STACK_MODE_ABOVE as u32;
const WIN_BORDER: u16 = xcb::CONFIG_WINDOW_BORDER_WIDTH as u16;
const WIN_HEIGHT: u16 = xcb::CONFIG_WINDOW_HEIGHT as u16;
const WIN_WIDTH: u16 = xcb::CONFIG_WINDOW_WIDTH as u16;
const WIN_X: u16 = xcb::CONFIG_WINDOW_X as u16;
const WIN_Y: u16 = xcb::CONFIG_WINDOW_Y as u16;

// masks
const XCB_RESPONSE_TYPE_MASK: u8 = 0x7F;
const NUMLOCK_MASK: u16 = xcb::MOD_MASK_2 as u16;
const NOTIFY_MASK: u16 = (xcb::randr::NOTIFY_MASK_OUTPUT_CHANGE
    | xcb::randr::NOTIFY_MASK_CRTC_CHANGE
    | xcb::randr::NOTIFY_MASK_SCREEN_CHANGE) as u16;
const NEW_WINDOW_MASK: u32 = xcb::EVENT_MASK_ENTER_WINDOW
    | xcb::EVENT_MASK_LEAVE_WINDOW
    | xcb::EVENT_MASK_PROPERTY_CHANGE
    | xcb::EVENT_MASK_STRUCTURE_NOTIFY;
const MOUSE_MASK: u16 = (xcb::EVENT_MASK_BUTTON_PRESS
    | xcb::EVENT_MASK_BUTTON_RELEASE
    | xcb::EVENT_MASK_BUTTON_MOTION) as u16;
const EVENT_MASK: u32 = xcb::EVENT_MASK_PROPERTY_CHANGE
    | xcb::EVENT_MASK_SUBSTRUCTURE_REDIRECT
    | xcb::EVENT_MASK_SUBSTRUCTURE_NOTIFY
    | xcb::EVENT_MASK_BUTTON_MOTION;

// Internal representation of X atoms to get a little bit of type safety around their use
#[derive(AsRefStr, EnumString, EnumIter, Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub(crate) enum Atom {
    #[strum(serialize = "ATOM")]
    Atom,
    #[strum(serialize = "ATOM_WINDOW")]
    Window,
    #[strum(serialize = "ATOM_CARDINAL")]
    Cardinal,
    #[strum(serialize = "MANAGER")]
    Manager,
    #[strum(serialize = "UTF8_STRING")]
    UTF8String,
    #[strum(serialize = "WM_CLASS")]
    WmClass,
    #[strum(serialize = "WM_DELETE_WINDOW")]
    WmDeleteWindow,
    #[strum(serialize = "WM_PROTOCOLS")]
    WmProtocols,
    #[strum(serialize = "WM_STATE")]
    WmState,
    #[strum(serialize = "WM_NAME")]
    WmName,
    #[strum(serialize = "WM_TAKE_FOCUS")]
    WmTakeFocus,
    #[strum(serialize = "_NET_ACTIVE_WINDOW")]
    NetActiveWindow,
    #[strum(serialize = "_NET_CLIENT_LIST")]
    NetClientList,
    #[strum(serialize = "_NET_CURRENT_DESKTOP")]
    NetCurrentDesktop,
    #[strum(serialize = "_NET_DESKTOP_NAMES")]
    NetDesktopNames,
    #[strum(serialize = "_NET_NUMBER_OF_DESKTOPS")]
    NetNumberOfDesktops,
    #[strum(serialize = "_NET_SUPPORTED")]
    NetSupported,
    #[strum(serialize = "_NET_SUPPORTING_WM_CHECK")]
    NetSupportingWmCheck,
    #[strum(serialize = "_NET_SYSTEM_TRAY_OPCODE")]
    NetSystemTrayOpcode,
    #[strum(serialize = "_NET_SYSTEM_TRAY_ORIENTATION")]
    NetSystemTrayOrientation,
    #[strum(serialize = "_NET_SYSTEM_TRAY_ORIENTATION_HORZ")]
    NetSystemTrayOrientationHorz,
    #[strum(serialize = "_NET_SYSTEM_TRAY_S0")]
    NetSystemTrayS0,
    #[strum(serialize = "_NET_WM_DESKTOP")]
    NetWmDesktop,
    #[strum(serialize = "_NET_WM_NAME")]
    NetWmName,
    #[strum(serialize = "_NET_WM_STATE")]
    NetWmState,
    #[strum(serialize = "_NET_WM_STATE_FULLSCREEN")]
    NetWmStateFullscreen,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE")]
    NetWmWindowType,
    #[strum(serialize = "_XEMBED")]
    XEmbed,
    #[strum(serialize = "_XEMBED_INFO")]
    XEmbedInfo,

    // Window Types
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_DESKTOP")]
    NetWindowTypeDesktop,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_DOCK")]
    NetWindowTypeDock,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_TOOLBAR")]
    NetWindowTypeToolbar,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_MENU")]
    NetWindowTypeMenu,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_UTILITY")]
    NetWindowTypeUtility,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_SPLASH")]
    NetWindowTypeSplash,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_DIALOG")]
    NetWindowTypeDialog,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_DROPDOWN_MENU")]
    NetWindowTypeDropdownMenu,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_POPUP_MENU")]
    NetWindowTypePopupMenu,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_NOTIFICATION")]
    NetWindowTypeNotification,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_COMBO")]
    NetWindowTypeCombo,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_DND")]
    NetWindowTypeDnd,
    #[strum(serialize = "_NET_WM_WINDOW_TYPE_NORMAL")]
    NetWindowTypeNormal,
}

// Clients with one of these window types will be auto floated
const AUTO_FLOAT_WINDOW_TYPES: &[Atom] = &[
    Atom::NetWindowTypeDesktop,
    Atom::NetWindowTypeDialog,
    Atom::NetWindowTypeDock,
    Atom::NetWindowTypeDropdownMenu,
    Atom::NetWindowTypeMenu,
    Atom::NetWindowTypeNotification,
    Atom::NetWindowTypePopupMenu,
    Atom::NetWindowTypeSplash,
    Atom::NetWindowTypeToolbar,
    Atom::NetWindowTypeUtility,
];

const UNMANAGED_WINDOW_TYPES: &[Atom] = &[Atom::NetWindowTypeDock, Atom::NetWindowTypeToolbar];

/**
 * Wrapper around the low level XCB event types that require casting to work with.
 * Not all event fields are extracted so check the XCB documentation and update
 * accordingly if you need access to something that isn't currently passed through
 * to the WindowManager event loop.
 *
 * <https://tronche.com/gui/x/xlib/events/types.html>
 * <https://github.com/rtbo/rust-xcb/xml/xproto.xml>
 */
#[derive(Debug, Clone)]
pub enum XEvent {
    /// xcb docs: <https://www.mankier.com/3/xcb_button_press_event_t>
    /// xcb docs: <https://www.mankier.com/3/xcb_motion_notify_event_t>
    MouseEvent(MouseEvent),

    /// xcb docs: <https://www.mankier.com/3/xcb_input_device_key_press_event_t>
    KeyPress(KeyCode),

    /// xcb docs: <https://www.mankier.com/3/xcb_map_request_event_t>
    MapRequest {
        /// The ID of the window that wants to be mapped
        id: WinId,
        /// Whether or not the WindowManager should handle this window.
        ignore: bool,
    },

    /// xcb docs: <https://www.mankier.com/3/xcb_enter_notify_event_t>
    Enter {
        /// The ID of the window that was entered
        id: WinId,
        /// Absolute coordinate of the event
        rpt: Point,
        /// Coordinate of the event relative to top-left of the window itself
        wpt: Point,
    },

    /// xcb docs: <https://www.mankier.com/3/xcb_enter_notify_event_t>
    Leave {
        /// The ID of the window that was left
        id: WinId,
        /// Absolute coordinate of the event
        rpt: Point,
        /// Coordinate of the event relative to top-left of the window itself
        wpt: Point,
    },

    /// xcb docs: <https://www.mankier.com/3/xcb_destroy_notify_event_t>
    Destroy {
        /// The ID of the window being destroyed
        id: WinId,
    },

    /// xcb docs: <https://www.mankier.com/3/xcb_randr_screen_change_notify_event_t>
    ScreenChange,

    /// xcb docs: <https://www.mankier.com/3/xcb_randr_notify_event_t>
    RandrNotify,

    /// xcb docs: <https://www.mankier.com/3/xcb_configure_notify_event_t>
    ConfigureNotify {
        /// The ID of the window that had a property changed
        id: WinId,
        /// The new window size
        r: Region,
        /// Is this window the root window?
        is_root: bool,
    },

    /// xcb docs: <https://www.mankier.com/3/xcb_property_notify_event_t>
    PropertyNotify {
        /// The ID of the window that had a property changed
        id: WinId,
        /// The property that changed
        atom: String,
        /// Is this window the root window?
        is_root: bool,
    },

    /// <https://www.mankier.com/3/xcb_client_message_event_t>
    ClientMessage {
        /// The ID of the window that sent the message
        id: WinId,
        /// The data type being set
        dtype: String,
        /// The data itself
        data: Vec<usize>,
    },
}

/**
 * A handle on a running X11 connection that we can use for issuing X requests.
 *
 * XConn is intended as an abstraction layer to allow for communication with the underlying display
 * system (assumed to be X) using whatever mechanism the implementer wishes. In theory, it should
 * be possible to write an implementation that allows penrose to run on systems not using X as the
 * windowing system but X idioms and high level event types / client interations are assumed.
 **/
pub trait XConn {
    /// Flush pending actions to the X event loop
    fn flush(&self) -> bool;

    /// Wait for the next event from the X server and return it as an XEvent
    fn wait_for_event(&self) -> Option<XEvent>;

    /// Determine the currently connected CRTCs and return their details
    fn current_outputs(&self) -> Vec<Screen>;

    /// Determine the current (x,y) position of the cursor relative to the root window.
    fn cursor_position(&self) -> Point;

    /// Reposition the window identified by 'id' to the specifed region
    fn position_window(&self, id: WinId, r: Region, border: u32, stack_above: bool);

    /// Raise the window to the top of the stack so it renders above peers
    fn raise_window(&self, id: WinId);

    /// Mark the given window as newly created
    fn mark_new_window(&self, id: WinId);

    /// Map a window to the display. Called each time a map_notify event is received
    fn map_window(&self, id: WinId);

    /// Unmap a window from the display. Called each time an unmap_notify event is received
    fn unmap_window(&self, id: WinId);

    /// Send an X event to the target window
    fn send_client_event(&self, id: WinId, atom_name: &str) -> Result<()>;

    /// Return the client ID of the Client that currently holds X focus
    fn focused_client(&self) -> WinId;

    /// Mark the given client as having focus
    fn focus_client(&self, id: WinId);

    /// Change the border color for the given client
    fn set_client_border_color(&self, id: WinId, color: u32);

    /**
     * Notify the X server that we are intercepting the user specified key bindings
     * and prevent them being passed through to the underlying applications. This
     * is what determines which key press events end up being sent through in the
     * main event loop for the WindowManager.
     */
    fn grab_keys(&self, key_bindings: &KeyBindings, mouse_bindings: &MouseBindings);

    /// Set required EWMH properties to ensure compatability with external programs
    fn set_wm_properties(&self, workspaces: &[&str]);

    /// Update the root window properties with the current desktop details
    fn update_desktops(&self, workspaces: &[&str]);

    /// Update which desktop is currently focused
    fn set_current_workspace(&self, wix: usize);

    /// Set the WM_NAME prop of the root window
    fn set_root_window_name(&self, name: &str);

    /// Update which desktop a client is currently on
    fn set_client_workspace(&self, id: WinId, wix: usize);

    /// Toggle the fullscreen state of the given client ID with the X server
    fn toggle_client_fullscreen(&self, id: WinId, client_is_fullscreen: bool);

    /// Determine whether the target window should be tiled or allowed to float
    fn window_should_float(&self, id: WinId, floating_classes: &[&str]) -> bool;

    /// Check to see if this window is one that we should be handling or not
    fn is_managed_window(&self, id: WinId) -> bool;

    /// Return the current (x, y, w, h) dimensions of the requested window
    fn window_geometry(&self, id: WinId) -> Result<Region>;

    /**
     * Warp the cursor to be within the specified window. If win_id == None then behaviour is
     * definined by the implementor (e.g. warp cursor to active window, warp to center of screen)
     */
    fn warp_cursor(&self, id: Option<WinId>, screen: &Screen);

    /// Run on startup/restart to determine already running windows that we need to track
    fn query_for_active_windows(&self) -> Vec<WinId>;

    /**
     * Use the xcb api to query a string property for a window by window ID and poperty name.
     * Can fail if the property name is invalid or we get a malformed response from xcb.
     */
    fn str_prop(&self, id: u32, name: &str) -> Result<String>;

    /**
     * Fetch an atom prop by name for a particular window ID
     * Can fail if the property name is invalid or we get a malformed response from xcb.
     */
    fn atom_prop(&self, id: u32, name: &str) -> Result<u32>;

    /// Intern an X atom by name and return the corresponding ID
    fn intern_atom(&self, atom: &str) -> Result<u32>;

    /// Perform any state cleanup required prior to shutting down the window manager
    fn cleanup(&self);
}

/**
 * A really simple stub implementation of XConn to simplify setting up test cases.
 *
 * Intended use is to override the mock_* methods that you need for running your test
 * case in order to inject behaviour into a WindowManager instance which is driven
 * by X server state. StubXConn will then implement XConn and call through to your
 * overwritten methods or the provided default.
 *
 * This is being done to avoid providing broken default methods on the real XConn trait
 * that would make writing real impls more error prone if and when new methods are
 * added to the trait.
 */
pub trait StubXConn {
    /// Mocked
    fn mock_flush(&self) -> bool {
        true
    }

    /// Mocked
    fn mock_wait_for_event(&self) -> Option<XEvent> {
        None
    }

    /// Mocked
    fn mock_current_outputs(&self) -> Vec<Screen> {
        vec![]
    }

    /// Mocked
    fn mock_cursor_position(&self) -> Point {
        Point::new(0, 0)
    }

    /// Mocked
    fn mock_send_client_event(&self, _: WinId, _: &str) -> Result<()> {
        Ok(())
    }

    /// Mocked
    fn mock_focused_client(&self) -> WinId {
        0
    }

    /// Mocked
    fn mock_window_should_float(&self, _: WinId, _: &[&str]) -> bool {
        false
    }

    /// Mocked
    fn mock_is_managed_window(&self, _: WinId) -> bool {
        true
    }

    /// Mocked
    fn mock_window_geometry(&self, _: WinId) -> Result<Region> {
        Ok(Region::new(0, 0, 0, 0))
    }

    /// Mocked
    fn mock_query_for_active_windows(&self) -> Vec<WinId> {
        Vec::new()
    }

    /// Mocked
    fn mock_str_prop(&self, _: u32, name: &str) -> Result<String> {
        Ok(String::from(name))
    }

    /// Mocked
    fn mock_atom_prop(&self, id: u32, _: &str) -> Result<u32> {
        Ok(id)
    }

    /// Mocked
    fn mock_intern_atom(&self, _: &str) -> Result<u32> {
        Ok(0)
    }

    /// Mocked
    fn mock_warp_cursor(&self, _: Option<WinId>, _: &Screen) {}
    /// Mocked
    fn mock_focus_client(&self, _: WinId) {}
    /// Mocked
    fn mock_position_window(&self, _: WinId, _: Region, _: u32, _: bool) {}
    /// Mocked
    fn mock_raise_window(&self, _: WinId) {}
    /// Mocked
    fn mock_mark_new_window(&self, _: WinId) {}
    /// Mocked
    fn mock_map_window(&self, _: WinId) {}
    /// Mocked
    fn mock_unmap_window(&self, _: WinId) {}
    /// Mocked
    fn mock_set_client_border_color(&self, _: WinId, _: u32) {}
    /// Mocked
    fn mock_grab_keys(&self, _: &KeyBindings, _: &MouseBindings) {}
    /// Mocked
    fn mock_set_wm_properties(&self, _: &[&str]) {}
    /// Mocked
    fn mock_update_desktops(&self, _: &[&str]) {}
    /// Mocked
    fn mock_set_current_workspace(&self, _: usize) {}
    /// Mocked
    fn mock_set_root_window_name(&self, _: &str) {}
    /// Mocked
    fn mock_set_client_workspace(&self, _: WinId, _: usize) {}
    /// Mocked
    fn mock_toggle_client_fullscreen(&self, _: WinId, _: bool) {}
    /// Mocked
    fn mock_cleanup(&self) {}
}

impl<T> XConn for T
where
    T: StubXConn,
{
    fn flush(&self) -> bool {
        self.mock_flush()
    }

    fn wait_for_event(&self) -> Option<XEvent> {
        self.mock_wait_for_event()
    }

    fn current_outputs(&self) -> Vec<Screen> {
        self.mock_current_outputs()
    }

    fn cursor_position(&self) -> Point {
        self.mock_cursor_position()
    }

    fn position_window(&self, id: WinId, r: Region, border: u32, stack_above: bool) {
        self.mock_position_window(id, r, border, stack_above)
    }

    fn raise_window(&self, id: WinId) {
        self.mock_raise_window(id)
    }

    fn mark_new_window(&self, id: WinId) {
        self.mock_mark_new_window(id)
    }

    fn map_window(&self, id: WinId) {
        self.mock_map_window(id)
    }

    fn unmap_window(&self, id: WinId) {
        self.mock_unmap_window(id)
    }

    fn send_client_event(&self, id: WinId, atom_name: &str) -> Result<()> {
        self.mock_send_client_event(id, atom_name)
    }

    fn focused_client(&self) -> WinId {
        self.mock_focused_client()
    }

    fn focus_client(&self, id: WinId) {
        self.mock_focus_client(id)
    }

    fn set_client_border_color(&self, id: WinId, color: u32) {
        self.mock_set_client_border_color(id, color)
    }

    fn grab_keys(&self, key_bindings: &KeyBindings, mouse_bindings: &MouseBindings) {
        self.mock_grab_keys(key_bindings, mouse_bindings)
    }

    fn set_wm_properties(&self, workspaces: &[&str]) {
        self.mock_set_wm_properties(workspaces)
    }

    fn update_desktops(&self, workspaces: &[&str]) {
        self.mock_update_desktops(workspaces)
    }

    fn set_current_workspace(&self, wix: usize) {
        self.mock_set_current_workspace(wix)
    }

    fn set_root_window_name(&self, name: &str) {
        self.mock_set_root_window_name(name)
    }

    fn set_client_workspace(&self, id: WinId, wix: usize) {
        self.mock_set_client_workspace(id, wix)
    }

    fn toggle_client_fullscreen(&self, id: WinId, client_is_fullscreen: bool) {
        self.mock_toggle_client_fullscreen(id, client_is_fullscreen)
    }

    fn window_should_float(&self, id: WinId, floating_classes: &[&str]) -> bool {
        self.mock_window_should_float(id, floating_classes)
    }

    fn is_managed_window(&self, id: WinId) -> bool {
        self.mock_is_managed_window(id)
    }

    fn window_geometry(&self, id: WinId) -> Result<Region> {
        self.mock_window_geometry(id)
    }

    fn warp_cursor(&self, id: Option<WinId>, screen: &Screen) {
        self.mock_warp_cursor(id, screen)
    }

    fn query_for_active_windows(&self) -> Vec<WinId> {
        self.mock_query_for_active_windows()
    }

    fn str_prop(&self, id: u32, name: &str) -> Result<String> {
        self.mock_str_prop(id, name)
    }

    fn atom_prop(&self, id: u32, name: &str) -> Result<u32> {
        self.mock_atom_prop(id, name)
    }

    fn intern_atom(&self, atom: &str) -> Result<u32> {
        self.mock_intern_atom(atom)
    }

    fn cleanup(&self) {
        self.mock_cleanup()
    }
}

/**
 * Handles communication with an X server via the XCB library.
 *
 * XcbConnection is a minimal implementation that does not make use of the full asyc capabilities
 * of the underlying C XCB library.
 **/
pub struct XcbConnection {
    conn: xcb::Connection,
    root: WinId,
    check_win: WinId,
    atoms: HashMap<Atom, u32>,
    auto_float_types: Vec<u32>,
    dont_manage_types: Vec<String>,
    randr_base: u8,
}

impl XcbConnection {
    /// Establish a new connection to the running X server. Fails if unable to connect
    pub fn new() -> Result<XcbConnection> {
        let (conn, _) = xcb::Connection::connect(None)?;
        let root = conn
            .get_setup()
            .roots()
            .next()
            .ok_or_else(|| anyhow!("unable to get handle for screen"))?
            .root();

        // https://www.mankier.com/3/xcb_intern_atom
        let atoms: HashMap<Atom, u32> = Atom::iter()
            .map(|atom| {
                // false == always return the atom, even if exists already
                let val = xcb::intern_atom(&conn, false, atom.as_ref())
                    .get_reply()
                    .unwrap()
                    .atom();

                (atom, val)
            })
            .collect();

        let auto_float_types: Vec<u32> = AUTO_FLOAT_WINDOW_TYPES
            .iter()
            .map(|atom| *atoms.get(&atom).unwrap())
            .collect();

        let dont_manage_types: Vec<String> = UNMANAGED_WINDOW_TYPES
            .iter()
            .map(|&atom| atom.as_ref().to_string())
            .collect();

        let check_win = conn.generate_id();

        // xcb docs: https://www.mankier.com/3/xcb_create_window
        xcb::create_window(
            &conn,                   // xcb connection to X11
            0,                       // new window's depth
            check_win,               // ID to be used for referring to the window
            root,                    // parent window
            0,                       // x-coordinate
            0,                       // y-coordinate
            1,                       // width
            1,                       // height
            0,                       // border width
            WINDOW_CLASS_INPUT_ONLY, // class (i _think_ 0 == COPY_FROM_PARENT?)
            0,                       // visual (i _think_ 0 == COPY_FROM_PARENT?)
            &[],                     // value list? (value mask? not documented either way...)
        );

        let randr_base = conn
            .get_extension_data(&mut xcb::randr::id())
            .ok_or_else(|| anyhow!("unable to fetch extension data"))?
            .first_event();

        // xcb docs: https://www.mankier.com/3/xcb_randr_select_input
        xcb::randr::select_input(&conn, root, NOTIFY_MASK).request_check()?;

        Ok(XcbConnection {
            conn,
            root,
            check_win,
            atoms,
            auto_float_types,
            dont_manage_types,
            randr_base,
        })
    }

    // Return the cached atom if it's one we know, falling back to interning the atom if we need to.
    fn atom(&self, name: &str) -> Result<u32> {
        match self.atoms.get(&Atom::from_str(name)?) {
            Some(&a) => Ok(a),
            None => xcb::intern_atom(&self.conn, false, name)
                .get_reply()
                .map(|r| r.atom())
                .map_err(|err| anyhow!("unable to intern xcb atom '{}': {}", name, err)),
        }
    }

    // All 'Atom' variants were interned on init so this should always be safe to unwrap
    fn known_atom(&self, atom: Atom) -> u32 {
        *self.atoms.get(&atom).unwrap()
    }

    fn window_has_type_in(&self, id: WinId, win_types: &[u32]) -> bool {
        if let Ok(atom) = self.atom_prop(id, Atom::NetWmWindowType.as_ref()) {
            return win_types.contains(&atom);
        }
        false
    }
}

impl XConn for XcbConnection {
    fn flush(&self) -> bool {
        self.conn.flush()
    }

    fn wait_for_event(&self) -> Option<XEvent> {
        self.conn.wait_for_event().and_then(|event| {
            let etype = event.response_type() & XCB_RESPONSE_TYPE_MASK;
            // Need to apply the randr_base mask as well which doesn't seem to work in 'match'
            if etype == self.randr_base + xcb::randr::NOTIFY {
                return Some(XEvent::RandrNotify);
            }

            match etype {
                xcb::BUTTON_PRESS => {
                    let e: &xcb::ButtonPressEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::MouseEvent(MouseEvent::from_press(e).ok()?))
                }

                xcb::BUTTON_RELEASE => {
                    let e: &xcb::ButtonReleaseEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::MouseEvent(MouseEvent::from_release(e).ok()?))
                }

                xcb::MOTION_NOTIFY => {
                    let e: &xcb::MotionNotifyEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::MouseEvent(MouseEvent::from_motion(e).ok()?))
                }

                xcb::KEY_PRESS => {
                    let e: &xcb::KeyPressEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::KeyPress(
                        KeyCode::from_key_press(e).ignoring_modifier(NUMLOCK_MASK),
                    ))
                }

                xcb::MAP_REQUEST => {
                    let e: &xcb::MapRequestEvent = unsafe { xcb::cast_event(&event) };
                    let id = e.window();
                    xcb::xproto::get_window_attributes(&self.conn, id)
                        .get_reply()
                        .ok()
                        .map(|r| XEvent::MapRequest {
                            id,
                            ignore: r.override_redirect(),
                        })
                }

                xcb::ENTER_NOTIFY => {
                    let e: &xcb::EnterNotifyEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::Enter {
                        id: e.event(),
                        rpt: Point::new(e.root_x() as u32, e.root_y() as u32),
                        wpt: Point::new(e.event_x() as u32, e.event_y() as u32),
                    })
                }

                xcb::LEAVE_NOTIFY => {
                    let e: &xcb::LeaveNotifyEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::Leave {
                        id: e.event(),
                        rpt: Point::new(e.root_x() as u32, e.root_y() as u32),
                        wpt: Point::new(e.event_x() as u32, e.event_y() as u32),
                    })
                }

                xcb::DESTROY_NOTIFY => {
                    let e: &xcb::MapNotifyEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::Destroy { id: e.window() })
                }

                xcb::randr::SCREEN_CHANGE_NOTIFY => Some(XEvent::ScreenChange),

                xcb::CONFIGURE_NOTIFY => {
                    let e: &xcb::ConfigureNotifyEvent = unsafe { xcb::cast_event(&event) };
                    Some(XEvent::ConfigureNotify {
                        id: e.window(),
                        r: Region::new(
                            e.x() as u32,
                            e.y() as u32,
                            e.width() as u32,
                            e.height() as u32,
                        ),
                        is_root: e.window() == self.root,
                    })
                }

                xcb::CLIENT_MESSAGE => {
                    let e: &xcb::ClientMessageEvent = unsafe { xcb::cast_event(&event) };
                    xcb::xproto::get_atom_name(&self.conn, e.type_())
                        .get_reply()
                        .ok()
                        .map(|a| XEvent::ClientMessage {
                            id: e.window(),
                            dtype: a.name().to_string(),
                            data: match e.format() {
                                8 => e.data().data8().iter().map(|&d| d as usize).collect(),
                                16 => e.data().data16().iter().map(|&d| d as usize).collect(),
                                32 => e.data().data32().iter().map(|&d| d as usize).collect(),
                                _ => unreachable!(
                                    "ClientMessageEvent.format should really be an enum..."
                                ),
                            },
                        })
                }

                xcb::PROPERTY_NOTIFY => {
                    let e: &xcb::PropertyNotifyEvent = unsafe { xcb::cast_event(&event) };
                    xcb::xproto::get_atom_name(&self.conn, e.atom())
                        .get_reply()
                        .ok()
                        .and_then(|a| {
                            let atom = a.name().to_string();
                            let is_root = e.window() == self.root;
                            if is_root && !(atom == "WM_NAME" || atom == "_NET_WM_NAME") {
                                None
                            } else {
                                Some(XEvent::PropertyNotify {
                                    id: e.window(),
                                    atom,
                                    is_root,
                                })
                            }
                        })
                }

                // NOTE: ignoring other event types
                _ => None,
            }
        })
    }

    fn current_outputs(&self) -> Vec<Screen> {
        // xcb docs: https://www.mankier.com/3/xcb_randr_get_screen_resources
        let resources = xcb::randr::get_screen_resources(&self.conn, self.check_win);

        // xcb docs: https://www.mankier.com/3/xcb_randr_get_crtc_info
        match resources.get_reply() {
            Err(e) => panic!("error reading X screen resources: {}", e),
            Ok(reply) => reply
                .crtcs()
                .iter()
                .flat_map(|c| xcb::randr::get_crtc_info(&self.conn, *c, 0).get_reply())
                .enumerate()
                .map(|(i, r)| Screen::from_crtc_info_reply(r, i))
                .filter(|s| {
                    let (_, _, w, _) = s.region(false).values();
                    w > 0
                })
                .collect(),
        }
    }

    fn cursor_position(&self) -> Point {
        let cookie = xcb::query_pointer(&self.conn, self.root);

        cookie.get_reply().map_or_else(
            |_| Point::new(0, 0),
            |reply| Point::new(reply.root_x() as u32, reply.root_y() as u32),
        )
    }

    fn position_window(&self, id: WinId, reg: Region, border: u32, stack_above: bool) {
        let (x, y, w, h) = reg.values();
        let mut args = vec![
            (WIN_X, x),
            (WIN_Y, y),
            (WIN_WIDTH, w),
            (WIN_HEIGHT, h),
            (WIN_BORDER, border),
        ];
        if stack_above {
            args.push((STACK_MODE, STACK_ABOVE));
        }

        // xcb docs: https://www.mankier.com/3/xcb_configure_window
        xcb::configure_window(&self.conn, id, &args);
    }

    fn raise_window(&self, id: WinId) {
        // xcb docs: https://www.mankier.com/3/xcb_configure_window
        xcb::configure_window(&self.conn, id, &[(STACK_MODE, STACK_ABOVE)]);
    }

    fn mark_new_window(&self, id: WinId) {
        // xcb docs: https://www.mankier.com/3/xcb_change_window_attributes
        xcb::change_window_attributes(&self.conn, id, &[(xcb::CW_EVENT_MASK, NEW_WINDOW_MASK)]);
    }

    fn map_window(&self, id: WinId) {
        xcb::map_window(&self.conn, id);
    }

    fn unmap_window(&self, id: WinId) {
        xcb::unmap_window(&self.conn, id);
    }

    fn send_client_event(&self, id: WinId, atom_name: &str) -> Result<()> {
        let atom = self.atom(atom_name)?;
        let wm_protocols = self.known_atom(Atom::WmProtocols);
        let data = xcb::ClientMessageData::from_data32([atom, xcb::CURRENT_TIME, 0, 0, 0]);
        let event = xcb::ClientMessageEvent::new(32, id, wm_protocols, data);
        xcb::send_event(&self.conn, false, id, xcb::EVENT_MASK_NO_EVENT, &event);
        Ok(())
    }

    fn focused_client(&self) -> WinId {
        // xcb docs: https://www.mankier.com/3/xcb_get_input_focus
        xcb::get_input_focus(&self.conn)
            .get_reply()
            .map_or(0, |resp| resp.focus())
    }

    fn focus_client(&self, id: WinId) {
        let prop = self.known_atom(Atom::NetActiveWindow);

        // xcb docs: https://www.mankier.com/3/xcb_set_input_focus
        xcb::set_input_focus(
            &self.conn,         // xcb connection to X11
            INPUT_FOCUS_PARENT, // focus the parent when focus is lost
            id,                 // window to focus
            0,                  // current time to avoid network race conditions (0 == current time)
        );

        // xcb docs: https://www.mankier.com/3/xcb_change_property
        xcb::change_property(
            &self.conn,        // xcb connection to X11
            PROP_MODE_REPLACE, // discard current prop and replace
            self.root,         // window to change prop on
            prop,              // prop to change
            ATOM_WINDOW,       // type of prop
            32,                // data format (8/16/32-bit)
            &[id],             // data
        );
    }

    fn set_client_border_color(&self, id: WinId, color: u32) {
        xcb::change_window_attributes(&self.conn, id, &[(xcb::CW_BORDER_PIXEL, color)]);
    }

    fn toggle_client_fullscreen(&self, id: WinId, client_is_fullscreen: bool) {
        let state_prop = self.known_atom(Atom::NetWmState);
        let data = if client_is_fullscreen {
            0
        } else {
            self.known_atom(Atom::NetWmStateFullscreen)
        };

        xcb::change_property(
            &self.conn,        // xcb connection to X11
            PROP_MODE_REPLACE, // discard current prop and replace
            id,                // window to change prop on
            state_prop,        // prop to change
            ATOM_ATOM,         // type of prop
            32,                // data format (8/16/32-bit)
            &[data],           // data
        );
    }

    fn grab_keys(&self, key_bindings: &KeyBindings, mouse_bindings: &MouseBindings) {
        // We need to explicitly grab NumLock as an additional modifier and then drop it later on
        // when we are passing events through to the WindowManager as NumLock alters the modifier
        // mask when it is active.
        let modifiers = &[0, NUMLOCK_MASK];

        for m in modifiers.iter() {
            for k in key_bindings.keys() {
                // xcb docs: https://www.mankier.com/3/xcb_grab_key
                xcb::grab_key(
                    &self.conn,      // xcb connection to X11
                    false,           // don't pass grabbed events through to the client
                    self.root,       // the window to grab: in this case the root window
                    k.mask | m,      // modifiers to grab
                    k.code,          // keycode to grab
                    GRAB_MODE_ASYNC, // don't lock pointer input while grabbing
                    GRAB_MODE_ASYNC, // don't lock keyboard input while grabbing
                );
            }

            for (_, state) in mouse_bindings.keys() {
                // xcb docs: https://www.mankier.com/3/xcb_grab_button
                xcb::grab_button(
                    &self.conn,       // xcb connection to X11
                    false,            // don't pass grabbed events through to the client
                    self.root,        // the window to grab: in this case the root window
                    MOUSE_MASK,       // which events are reported to the client
                    GRAB_MODE_ASYNC,  // don't lock pointer input while grabbing
                    GRAB_MODE_ASYNC,  // don't lock keyboard input while grabbing
                    xcb::NONE,        // don't confine the cursor to a specific window
                    xcb::NONE,        // don't change the cursor type
                    state.button(),   // the button to grab
                    state.mask() | m, // modifiers to grab
                );
            }
        }

        // xcb docs: https://www.mankier.com/3/xcb_change_window_attributes
        xcb::change_window_attributes(&self.conn, self.root, &[(xcb::CW_EVENT_MASK, EVENT_MASK)]);
        self.conn.flush();
    }

    fn set_wm_properties(&self, workspaces: &[&str]) {
        // xcb docs: https://www.mankier.com/3/xcb_change_property
        xcb::change_property(
            &self.conn,                                  // xcb connection to X11
            PROP_MODE_REPLACE,                           // discard current prop and replace
            self.check_win,                              // window to change prop on
            self.known_atom(Atom::NetSupportingWmCheck), // prop to change
            ATOM_WINDOW,                                 // type of prop
            32,                                          // data format (8/16/32-bit)
            &[self.check_win],                           // data
        );
        xcb::change_property(
            &self.conn,                        // xcb connection to X11
            PROP_MODE_REPLACE,                 // discard current prop and replace
            self.check_win,                    // window to change prop on
            self.known_atom(Atom::NetWmName),  // prop to change
            self.known_atom(Atom::UTF8String), // type of prop
            8,                                 // data format (8/16/32-bit)
            WM_NAME.as_bytes(),                // data
        );
        xcb::change_property(
            &self.conn,                                  // xcb connection to X11
            PROP_MODE_REPLACE,                           // discard current prop and replace
            self.root,                                   // window to change prop on
            self.known_atom(Atom::NetSupportingWmCheck), // prop to change
            ATOM_WINDOW,                                 // type of prop
            32,                                          // data format (8/16/32-bit)
            &[self.check_win],                           // data
        );
        xcb::change_property(
            &self.conn,                        // xcb connection to X11
            PROP_MODE_REPLACE,                 // discard current prop and replace
            self.root,                         // window to change prop on
            self.known_atom(Atom::NetWmName),  // prop to change
            self.known_atom(Atom::UTF8String), // type of prop
            8,                                 // data format (8/16/32-bit)
            WM_NAME.as_bytes(),                // data
        );

        // EWMH support
        let supported: Vec<u32> = Atom::iter().map(|a| self.known_atom(a)).collect();
        xcb::change_property(
            &self.conn,                          // xcb connection to X11
            PROP_MODE_REPLACE,                   // discard current prop and replace
            self.root,                           // window to change prop on
            self.known_atom(Atom::NetSupported), // prop to change
            ATOM_ATOM,                           // type of prop
            32,                                  // data format (8/16/32-bit)
            &supported,                          // data
        );
        self.update_desktops(workspaces);
        xcb::delete_property(&self.conn, self.root, self.known_atom(Atom::NetClientList));
    }

    fn update_desktops(&self, workspaces: &[&str]) {
        xcb::change_property(
            &self.conn,                                 // xcb connection to X11
            PROP_MODE_REPLACE,                          // discard current prop and replace
            self.root,                                  // window to change prop on
            self.known_atom(Atom::NetNumberOfDesktops), // prop to change
            ATOM_CARDINAL,                              // type of prop
            32,                                         // data format (8/16/32-bit)
            &[workspaces.len() as u32],                 // data
        );
        xcb::change_property(
            &self.conn,                             // xcb connection to X11
            PROP_MODE_REPLACE,                      // discard current prop and replace
            self.root,                              // window to change prop on
            self.known_atom(Atom::NetDesktopNames), // prop to change
            self.known_atom(Atom::UTF8String),      // type of prop
            8,                                      // data format (8/16/32-bit)
            workspaces.join("\0").as_bytes(),       // data
        );
    }

    fn set_current_workspace(&self, wix: usize) {
        xcb::change_property(
            &self.conn,                               // xcb connection to X11
            PROP_MODE_REPLACE,                        // discard current prop and replace
            self.root,                                // window to change prop on
            self.known_atom(Atom::NetCurrentDesktop), // prop to change
            xcb::xproto::ATOM_CARDINAL,               // type of prop
            32,                                       // data format (8/16/32-bit)
            &[wix as u32],                            // data
        );
    }

    fn set_root_window_name(&self, name: &str) {
        xcb::change_property(
            &self.conn,                        // xcb connection to X11
            PROP_MODE_REPLACE,                 // discard current prop and replace
            self.root,                         // window to change prop on
            self.known_atom(Atom::WmName),     // prop to change
            self.known_atom(Atom::UTF8String), // type of prop
            8,                                 // data format (8/16/32-bit)
            name.as_bytes(),                   // data
        );
    }

    fn set_client_workspace(&self, id: WinId, wix: usize) {
        xcb::change_property(
            &self.conn,                          // xcb connection to X11
            PROP_MODE_REPLACE,                   // discard current prop and replace
            id,                                  // window to change prop on
            self.known_atom(Atom::NetWmDesktop), // prop to change
            xcb::xproto::ATOM_CARDINAL,          // type of prop
            32,                                  // data format (8/16/32-bit)
            &[wix as u32],                       // data
        );
    }

    fn window_should_float(&self, id: WinId, floating_classes: &[&str]) -> bool {
        if let Ok(s) = self.str_prop(id, Atom::WmClass.as_ref()) {
            if s.split('\0').any(|c| floating_classes.contains(&c)) {
                return true;
            }
        }

        self.window_has_type_in(id, &self.auto_float_types)
    }

    fn is_managed_window(&self, id: WinId) -> bool {
        if let Ok(s) = self.str_prop(id, Atom::NetWmWindowType.as_ref()) {
            let ty = s.split('\0').collect::<Vec<&str>>()[0].to_string();
            !self.dont_manage_types.contains(&ty)
        } else {
            true // manage window by default
        }
    }

    fn window_geometry(&self, id: WinId) -> Result<Region> {
        let res = xcb::get_geometry(&self.conn, id).get_reply()?;
        Ok(Region::new(
            res.x() as u32,
            res.y() as u32,
            res.width() as u32,
            res.height() as u32,
        ))
    }

    fn warp_cursor(&self, win_id: Option<WinId>, screen: &Screen) {
        let (x, y, id) = match win_id {
            Some(id) => {
                let (_, _, w, h) = self.window_geometry(id).unwrap().values();
                ((w / 2) as i16, (h / 2) as i16, id)
            }
            None => {
                let (x, y, w, h) = screen.region(true).values();
                ((x + w / 2) as i16, (y + h / 2) as i16, self.root)
            }
        };

        xcb::warp_pointer(
            &self.conn, // xcb connection to X11
            0,          // source window
            id,         // destination window
            0,          // source x
            0,          // source y
            0,          // source width
            0,          // source height
            x,          // destination x
            y,          // destination y
        );
    }

    fn query_for_active_windows(&self) -> Vec<WinId> {
        let all_ids = match xcb::query_tree(&self.conn, self.root).get_reply() {
            Err(_) => Vec::new(),
            Ok(reply) => reply.children().into(),
        };

        let dont_manage: Vec<u32> = UNMANAGED_WINDOW_TYPES
            .iter()
            .map(|&t| self.known_atom(t))
            .collect();

        all_ids
            .iter()
            .filter(|&id| !self.window_has_type_in(*id, &dont_manage))
            .cloned()
            .collect()
    }

    fn str_prop(&self, id: u32, name: &str) -> Result<String> {
        // xcb docs: https://www.mankier.com/3/xcb_get_property
        let cookie = xcb::get_property(
            &self.conn,       // xcb connection to X11
            false,            // should the property be deleted
            id,               // target window to query
            self.atom(name)?, // the property we want
            xcb::ATOM_ANY,    // the type of the property
            0,                // offset in the property to retrieve data from
            1024,             // how many 32bit multiples of data to retrieve
        );

        Ok(String::from_utf8(cookie.get_reply()?.value().to_vec())?)
    }

    fn atom_prop(&self, id: u32, name: &str) -> Result<u32> {
        // xcb docs: https://www.mankier.com/3/xcb_get_property
        let cookie = xcb::get_property(
            &self.conn,       // xcb connection to X11
            false,            // should the property be deleted
            id,               // target window to query
            self.atom(name)?, // the property we want
            xcb::ATOM_ANY,    // the type of the property
            0,                // offset in the property to retrieve data from
            1024,             // how many 32bit multiples of data to retrieve
        );

        let reply = cookie.get_reply()?;
        if reply.value_len() == 0 {
            Err(anyhow!("property '{}' was empty for id: {}", name, id))
        } else {
            Ok(reply.value()[0])
        }
    }

    fn intern_atom(&self, atom: &str) -> Result<u32> {
        self.atom(atom)
    }

    // - Release all of the keybindings we are holding on to
    // - destroy the check window
    // - mark ourselves as no longer being the active root window
    fn cleanup(&self) {
        // xcb docs: https://www.mankier.com/3/xcb_ungrab_key
        xcb::ungrab_key(
            &self.conn, // xcb connection to X11
            xcb::GRAB_ANY as u8,
            self.root, // the window to ungrab keys for
            xcb::MOD_MASK_ANY as u16,
        );
        xcb::destroy_window(&self.conn, self.check_win);
        xcb::delete_property(
            &self.conn,
            self.root,
            self.known_atom(Atom::NetActiveWindow),
        );
    }
}

/// A dummy XConn implementation for testing
pub struct MockXConn {
    screens: Vec<Screen>,
    events: Cell<Vec<XEvent>>,
    focused: Cell<WinId>,
    unmanaged_ids: Vec<WinId>,
}

impl MockXConn {
    /// Set up a new MockXConn with pre-defined Screens and an event stream to pull from
    pub fn new(screens: Vec<Screen>, events: Vec<XEvent>, unmanaged_ids: Vec<WinId>) -> Self {
        MockXConn {
            screens,
            events: Cell::new(events),
            focused: Cell::new(0),
            unmanaged_ids,
        }
    }
}

impl StubXConn for MockXConn {
    fn mock_wait_for_event(&self) -> Option<XEvent> {
        let mut remaining = self.events.replace(vec![]);
        if remaining.is_empty() {
            return None;
        }
        let next = remaining.remove(0);
        self.events.set(remaining);
        Some(next)
    }

    fn mock_current_outputs(&self) -> Vec<Screen> {
        self.screens.clone()
    }

    fn mock_focused_client(&self) -> WinId {
        self.focused.get()
    }

    fn mock_focus_client(&self, id: WinId) {
        self.focused.replace(id);
    }

    fn mock_is_managed_window(&self, id: WinId) -> bool {
        !self.unmanaged_ids.contains(&id)
    }
}
